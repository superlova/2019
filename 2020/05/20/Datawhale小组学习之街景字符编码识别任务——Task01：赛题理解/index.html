<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content>
  <meta name="author" content="Superlova">
  <meta name="keywords" content>
  <title>Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解 - Superlova</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css">


<!-- 自定义样式保持在最底部 -->


<link rel="alternate" href="/atom.xml" title="Superlova" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Superlova</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期三, 五月 20日 2020, 4:38 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    2.7k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      12 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <p>本次新人赛是Datawhale与天池联合发起的0基础入门系列赛事第二场 —— 零基础入门CV之街景字符识别比赛。<br><a id="more"></a></p>
<h1 id="Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解"><a href="#Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解" class="headerlink" title="Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解"></a>Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解</h1><h2 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0. 学习目标"></a>0. 学习目标</h2><ul>
<li>理解赛题背景和赛题数据</li>
<li>完成赛题报名和数据下载，理解赛题的解题思路</li>
<li>了解赛题</li>
</ul>
<h2 id="1-大赛简介"><a href="#1-大赛简介" class="headerlink" title="1. 大赛简介"></a>1. 大赛简介</h2><p>本次新人赛是Datawhale与天池联合发起的0基础入门系列赛事第二场 —— 零基础入门CV之街景字符识别比赛。</p>
<h3 id="1-1-赛题数据介绍"><a href="#1-1-赛题数据介绍" class="headerlink" title="1.1 赛题数据介绍"></a>1.1 赛题数据介绍</h3><p>赛题来源自Google街景图像中的门牌号数据集（The Street View House Numbers Dataset, SVHN），该数据来自真实场景的门牌号。</p>
<p>训练集数据包括3W张照片，验证集数据包括1W张照片，每张照片包括颜色图像和对应的编码类别和具体位置</p>
<h3 id="1-2-参赛规则"><a href="#1-2-参赛规则" class="headerlink" title="1.2 参赛规则"></a>1.2 参赛规则</h3><ul>
<li>比赛允许使用CIFAR-10和ImageNet数据集的预训练模型，不允许使用其他任何预训练模型和任何外部数据；</li>
<li>报名成功后，选手下载数据，在本地调试算法，提交结果；</li>
<li>提交后将进行实时评测；每天排行榜更新时间为12:00和20:00，按照评测指标得分从高到低排序；排行榜将选择历史最优成绩进行展示。</li>
</ul>
<h3 id="1-3-数据集简介"><a href="#1-3-数据集简介" class="headerlink" title="1.3 数据集简介"></a>1.3 数据集简介</h3><p>所有的数据（训练集、验证集和测试集）的标注使用JSON格式，并使用文件名进行索引。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>左上角坐标X</td>
<td></td>
</tr>
<tr>
<td>height</td>
<td>字符高度</td>
<td></td>
</tr>
<tr>
<td>left</td>
<td>左上角最表Y</td>
<td></td>
</tr>
<tr>
<td>width</td>
<td>字符宽度</td>
<td></td>
</tr>
<tr>
<td>label</td>
<td>字符编码</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>字符的坐标具体如下所示：<br><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/字符坐标.png" srcset="/img/loading.gif" alt="坐标">  </p>
<p>在比赛数据（训练集和验证集）中，同一张图片中可能包括一个或者多个字符，因此在比赛数据的JSON标注中，会有两个字符的边框信息：<br>|原始图片|图片JSON标注|<br>|——|——-|<br><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/原始图片.png" srcset="/img/loading.gif" alt="19">    | <img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/原始图片标注.png" srcset="/img/loading.gif" alt="标注">  |</p>
<h3 id="1-4-成绩评定方式"><a href="#1-4-成绩评定方式" class="headerlink" title="1.4 成绩评定方式"></a>1.4 成绩评定方式</h3><p>评价标准为准确率。<br>选手提交结果与实际图片的编码进行对比，以编码整体识别准确率为评价指标，结果越大越好，具体计算公式如下：</p>
<p> Score=编码识别正确的数量/测试集图片数量   </p>
<h3 id="1-5-结果提交格式"><a href="#1-5-结果提交格式" class="headerlink" title="1.5 结果提交格式"></a>1.5 结果提交格式</h3><p>提交前请确保预测结果的格式与sample_submit.csv中的格式一致，以及提交文件后缀名为csv。<br>形式如下：<br>file_name, file_code<br>0010000.jpg,451<br>0010001.jpg,232<br>0010002.jpg,45<br>0010003.jpg,67<br>0010004.jpg,191<br>0010005.jpg,892 </p>
<h2 id="2-数据读取"><a href="#2-数据读取" class="headerlink" title="2. 数据读取"></a>2. 数据读取</h2><p>JSON中标签的读取方式：  </p>
<pre><code class="lang-python">import json
train_json = json.load(open(&#39;../input/train.json&#39;))

# 数据标注处理
def parse_json(d):
    arr = np.array([
        d[&#39;top&#39;], d[&#39;height&#39;], d[&#39;left&#39;],  d[&#39;width&#39;], d[&#39;label&#39;]
    ])
    arr = arr.astype(int)
    return arr

img = cv2.imread(&#39;../input/train/000000.png&#39;)
arr = parse_json(train_json[&#39;000000.png&#39;])

plt.figure(figsize=(10, 10))
plt.subplot(1, arr.shape[1]+1, 1)
plt.imshow(img)
plt.xticks([]); plt.yticks([])

for idx in range(arr.shape[1]):
    plt.subplot(1, arr.shape[1]+1, idx+2)
    plt.imshow(img[arr[0, idx]:arr[0, idx]+arr[1, idx],arr[2, idx]:arr[2, idx]+arr[3, idx]])
    plt.title(arr[4, idx])
    plt.xticks([]); plt.yticks([])
</code></pre>
<p><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/19.png" srcset="/img/loading.gif" alt="19"></p>
<h2 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3. 解题思路"></a>3. 解题思路</h2><p>赛题思路分析：赛题本质是分类问题，需要对图片的字符进行识别。但赛题给定的数据图片中不同图片中包含的字符数量不等，如下图所示。有的图片的字符个数为2，有的图片字符个数为3，有的图片字符个数为4。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符属性</th>
<th>图片</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符：42   字符个数：2</td>
<td><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/42.png" srcset="/img/loading.gif" alt="标注"></td>
</tr>
<tr>
<td>字符：241   字符个数：3</td>
<td><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/2411.png" srcset="/img/loading.gif" alt="标注"></td>
</tr>
<tr>
<td>字符：7358   字符个数：4</td>
<td><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/7358.png" srcset="/img/loading.gif" alt="标注"></td>
</tr>
</tbody>
</table>
</div>
<p>因此本次赛题的难点是需要对不定长的字符进行识别，与传统的图像分类任务有所不同。为了降低参赛难度，我们提供了一些解题思路供大家参考：</p>
<ul>
<li>简单入门思路：定长字符识别    </li>
</ul>
<p>可以将赛题抽象为一个定长字符识别问题，在赛题数据集中大部分图像中字符个数为2-4个，最多的字符    个数为6个。<br>因此可以对于所有的图像都抽象为6个字符的识别问题，字符23填充为23XXXX，字符231填充为231XXX。<br><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/23xxxxxx.png" srcset="/img/loading.gif" alt="标注">   </p>
<p>经过填充之后，原始的赛题可以简化了6个字符的分类问题。在每个字符的分类中会进行11个类别的分类，假如分类为填充字符，则表明该字符为空。    </p>
<ul>
<li>专业字符识别思路：不定长字符识别 </li>
</ul>
<p><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/不定长字符识别.png" srcset="/img/loading.gif" alt="标注"> </p>
<p>在字符识别研究中，有特定的方法来解决此种不定长的字符识别问题，比较典型的有CRNN字符识别模型。<br>在本次赛题中给定的图像数据都比较规整，可以视为一个单词或者一个句子。   </p>
<ul>
<li>专业分类思路：检测再识别</li>
</ul>
<p>在赛题数据中已经给出了训练集、验证集中所有图片中字符的位置，因此可以首先将字符的位置进行识别，利用物体检测的思路完成。   </p>
<p><img src="/2020/05/20/Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解/检测.png" srcset="/img/loading.gif" alt="IMG"> </p>
<p>此种思路需要参赛选手构建字符检测模型，对测试集中的字符进行识别。选手可以参考物体检测模型SSD或者YOLO来完成。    </p>
<h2 id="4-Baseline思路：将不定长字符转换为定长字符的识别问题，并使用CNN完成训练和验证"><a href="#4-Baseline思路：将不定长字符转换为定长字符的识别问题，并使用CNN完成训练和验证" class="headerlink" title="4. Baseline思路：将不定长字符转换为定长字符的识别问题，并使用CNN完成训练和验证"></a>4. Baseline思路：将不定长字符转换为定长字符的识别问题，并使用CNN完成训练和验证</h2><h3 id="4-1-步骤"><a href="#4-1-步骤" class="headerlink" title="4.1 步骤"></a>4.1 步骤</h3><ul>
<li>赛题数据读取（封装为Pytorch的Dataset和DataLoder）</li>
<li>构建CNN模型（使用Pytorch搭建）</li>
<li>模型训练与验证</li>
<li>模型结果预测</li>
</ul>
<h3 id="4-2-运行环境及安装示例"><a href="#4-2-运行环境及安装示例" class="headerlink" title="4.2 运行环境及安装示例"></a>4.2 运行环境及安装示例</h3><ul>
<li>运行环境要求：Python2/3，Pytorch1.x，内存4G，有无GPU都可以。         </li>
</ul>
<p>下面给出python3.7+ torch1.3.1gpu版本的环境安装示例：      </p>
<ul>
<li><p>首先在Anaconda中创建一个专门用于本次天池练习赛的虚拟环境。          </p>
<blockquote>
<p>$conda create -n py37_torch131 python=3.7      </p>
</blockquote>
</li>
<li><p>激活环境，并安装pytorch1.3.1                                     </p>
<blockquote>
<p>$source activate py37_torch131<br>$conda install pytorch=1.3.1 torchvision cudatoolkit=10.0                     </p>
</blockquote>
</li>
<li><p>通过下面的命令一键安装所需其它依赖库     </p>
<blockquote>
<p>$pip install jupyter tqdm opencv-python matplotlib pandas                                  </p>
</blockquote>
</li>
<li><p>启动notebook，即可开始baseline代码的学习                  </p>
<blockquote>
<p>$jupyter-notebook   </p>
</blockquote>
</li>
<li><p>假设所有的赛题输入文件放在../input/目录下，首先导入常用的包：<br>```python<br>import os, sys, glob, shutil, json<br>os.environ[“CUDA_VISIBLE_DEVICES”] = ‘0’<br>import cv2</p>
</li>
</ul>
<p>from PIL import Image<br>import numpy as np</p>
<p>from tqdm import tqdm, tqdm_notebook</p>
<p>import torch<br>torch.manual_seed(0)<br>torch.backends.cudnn.deterministic = False<br>torch.backends.cudnn.benchmark = True</p>
<p>import torchvision.models as models<br>import torchvision.transforms as transforms<br>import torchvision.datasets as datasets<br>import torch.nn as nn<br>import torch.nn.functional as F<br>import torch.optim as optim<br>from torch.autograd import Variable<br>from torch.utils.data.dataset import Dataset</p>
<pre><code>
- #### 步骤1：定义好读取图像的Dataset     
```python
class SVHNDataset(Dataset):
    def __init__(self, img_path, img_label, transform=None):
        self.img_path = img_path
        self.img_label = img_label 
        if transform is not None:
            self.transform = transform
        else:
            self.transform = None

    def __getitem__(self, index):
        img = Image.open(self.img_path[index]).convert(&#39;RGB&#39;)

        if self.transform is not None:
            img = self.transform(img)

        # 设置最长的字符长度为5个
        lbl = np.array(self.img_label[index], dtype=np.int)
        lbl = list(lbl)  + (5 - len(lbl)) * [10]
        return img, torch.from_numpy(np.array(lbl[:5]))

    def __len__(self):
        return len(self.img_path)
</code></pre><ul>
<li><h4 id="步骤2：定义好训练数据和验证数据的Dataset"><a href="#步骤2：定义好训练数据和验证数据的Dataset" class="headerlink" title="步骤2：定义好训练数据和验证数据的Dataset"></a>步骤2：定义好训练数据和验证数据的Dataset</h4>```python<br>train_path = glob.glob(‘../input/train/*.png’)<br>train_path.sort()<br>train_json = json.load(open(‘../input/train.json’))<br>train_label = [train_json[x][‘label’] for x in train_json]<br>print(len(train_path), len(train_label))</li>
</ul>
<p>train_loader = torch.utils.data.DataLoader(<br>    SVHNDataset(train_path, train_label,<br>                transforms.Compose([<br>                    transforms.Resize((64, 128)),<br>                    transforms.RandomCrop((60, 120)),<br>                    transforms.ColorJitter(0.3, 0.3, 0.2),<br>                    transforms.RandomRotation(5),<br>                    transforms.ToTensor(),<br>                    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])<br>    ])),<br>    batch_size=40,<br>    shuffle=True,<br>    num_workers=10,<br>)</p>
<p>val_path = glob.glob(‘../input/val/*.png’)<br>val_path.sort()<br>val_json = json.load(open(‘../input/val.json’))<br>val_label = [val_json[x][‘label’] for x in val_json]<br>print(len(val_path), len(val_label))</p>
<p>val_loader = torch.utils.data.DataLoader(<br>    SVHNDataset(val_path, val_label,<br>                transforms.Compose([<br>                    transforms.Resize((60, 120)),</p>
<pre><code>                # transforms.ColorJitter(0.3, 0.3, 0.2),
                # transforms.RandomRotation(5),
                transforms.ToTensor(),
                transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])), 
batch_size=40, 
shuffle=False, 
num_workers=10,
</code></pre><p>)</p>
<pre><code>

- #### 步骤3：定义好字符分类模型，使用renset18的模型作为特征提取模块     
```python
class SVHN_Model1(nn.Module):
    def __init__(self):
        super(SVHN_Model1, self).__init__()

        model_conv = models.resnet18(pretrained=True)
        model_conv.avgpool = nn.AdaptiveAvgPool2d(1)
        model_conv = nn.Sequential(*list(model_conv.children())[:-1])
        self.cnn = model_conv

        self.fc1 = nn.Linear(512, 11)
        self.fc2 = nn.Linear(512, 11)
        self.fc3 = nn.Linear(512, 11)
        self.fc4 = nn.Linear(512, 11)
        self.fc5 = nn.Linear(512, 11)

    def forward(self, img):        
        feat = self.cnn(img)
        # print(feat.shape)
        feat = feat.view(feat.shape[0], -1)
        c1 = self.fc1(feat)
        c2 = self.fc2(feat)
        c3 = self.fc3(feat)
        c4 = self.fc4(feat)
        c5 = self.fc5(feat)
        return c1, c2, c3, c4, c5
</code></pre><ul>
<li><h4 id="步骤4：定义好训练、验证和预测模块"><a href="#步骤4：定义好训练、验证和预测模块" class="headerlink" title="步骤4：定义好训练、验证和预测模块"></a>步骤4：定义好训练、验证和预测模块</h4><p>```python<br>def train(train_loader, model, criterion, optimizer):</p>
<h1 id="切换模型为训练模式"><a href="#切换模型为训练模式" class="headerlink" title="切换模型为训练模式"></a>切换模型为训练模式</h1><p>  model.train()<br>  train_loss = []</p>
<p>  for i, (input, target) in enumerate(train_loader):</p>
<pre><code>  if use_cuda:
      input = input.cuda()
      target = target.cuda()

  c0, c1, c2, c3, c4 = model(input)
  loss = criterion(c0, target[:, 0]) + \
          criterion(c1, target[:, 1]) + \
          criterion(c2, target[:, 2]) + \
          criterion(c3, target[:, 3]) + \
          criterion(c4, target[:, 4])

  # loss /= 6
  optimizer.zero_grad()
  loss.backward()
  optimizer.step()

  if i % 100 == 0:
      print(loss.item())

  train_loss.append(loss.item())
</code></pre><p>  return np.mean(train_loss)</p>
</li>
</ul>
<p>def validate(val_loader, model, criterion):</p>
<pre><code># 切换模型为预测模型
model.eval()
val_loss = []

# 不记录模型梯度信息
with torch.no_grad():
    for i, (input, target) in enumerate(val_loader):
        if use_cuda:
            input = input.cuda()
            target = target.cuda()

        c0, c1, c2, c3, c4 = model(input)
        loss = criterion(c0, target[:, 0]) + \
                criterion(c1, target[:, 1]) + \
                criterion(c2, target[:, 2]) + \
                criterion(c3, target[:, 3]) + \
                criterion(c4, target[:, 4])
        # loss /= 6
        val_loss.append(loss.item())
return np.mean(val_loss)
</code></pre><p>def predict(test_loader, model, tta=10):<br>    model.eval()<br>    test_pred_tta = None</p>
<pre><code># TTA 次数
for _ in range(tta):
    test_pred = []

    with torch.no_grad():
        for i, (input, target) in enumerate(test_loader):
            if use_cuda:
                input = input.cuda()

            c0, c1, c2, c3, c4 = model(input)
            output = np.concatenate([
                c0.data.numpy(), 
                c1.data.numpy(),
                c2.data.numpy(), 
                c3.data.numpy(),
                c4.data.numpy()], axis=1)
            test_pred.append(output)

    test_pred = np.vstack(test_pred)
    if test_pred_tta is None:
        test_pred_tta = test_pred
    else:
        test_pred_tta += test_pred

return test_pred_tta
</code></pre><pre><code>
- #### 步骤5：迭代训练和验证模型     
```python
model = SVHN_Model1()
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters(), 0.001)
best_loss = 1000.0

use_cuda = False
if use_cuda:
    model = model.cuda()

for epoch in range(2):
    train_loss = train(train_loader, model, criterion, optimizer, epoch)
    val_loss = validate(val_loader, model, criterion)

    val_label = [&#39;&#39;.join(map(str, x)) for x in val_loader.dataset.img_label]
    val_predict_label = predict(val_loader, model, 1)
    val_predict_label = np.vstack([
        val_predict_label[:, :11].argmax(1),
        val_predict_label[:, 11:22].argmax(1),
        val_predict_label[:, 22:33].argmax(1),
        val_predict_label[:, 33:44].argmax(1),
        val_predict_label[:, 44:55].argmax(1),
    ]).T
    val_label_pred = []
    for x in val_predict_label:
        val_label_pred.append(&#39;&#39;.join(map(str, x[x!=10])))

    val_char_acc = np.mean(np.array(val_label_pred) == np.array(val_label))

    print(&#39;Epoch: {0}, Train loss: {1} \t Val loss: {2}&#39;.format(epoch, train_loss, val_loss))
    print(val_char_acc)
    # 记录下验证集精度
    if val_loss &lt; best_loss:
        best_loss = val_loss
        torch.save(model.state_dict(), &#39;./model.pt&#39;)
</code></pre><p>训练两个2 Epoch后，输出的训练日志为：</p>
<p>Epoch: 0, Train loss: 3.1      Val loss: 3.4 验证集精度：0.3439<br>Epoch: 1, Train loss: 2.1      Val loss: 2.9 验证集精度：0.4346     </p>
<ul>
<li><h4 id="步骤6：对测试集样本进行预测，生成提交文件"><a href="#步骤6：对测试集样本进行预测，生成提交文件" class="headerlink" title="步骤6：对测试集样本进行预测，生成提交文件"></a>步骤6：对测试集样本进行预测，生成提交文件</h4>```python<br>test_path = glob.glob(‘../input/test_a/<em>.png’)<br>test_path.sort()<br>test_label = [[1]] </em> len(test_path)<br>print(len(val_path), len(val_label))</li>
</ul>
<p>test_loader = torch.utils.data.DataLoader(<br>    SVHNDataset(test_path, test_label,<br>                transforms.Compose([<br>                    transforms.Resize((64, 128)),<br>                    transforms.RandomCrop((60, 120)),</p>
<pre><code>                # transforms.ColorJitter(0.3, 0.3, 0.2),
                # transforms.RandomRotation(5),
                transforms.ToTensor(),
                transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])), 
batch_size=40, 
shuffle=False, 
num_workers=10,
</code></pre><p>)</p>
<p>test_predict_label = predict(test_loader, model, 1)</p>
<p>test_label = [‘’.join(map(str, x)) for x in test_loader.dataset.img_label]<br>test_predict_label = np.vstack([<br>    test_predict_label[:, :11].argmax(1),<br>    test_predict_label[:, 11:22].argmax(1),<br>    test_predict_label[:, 22:33].argmax(1),<br>    test_predict_label[:, 33:44].argmax(1),<br>    test_predict_label[:, 44:55].argmax(1),<br>]).T</p>
<p>test_label_pred = []<br>for x in test_predict_label:<br>    test_label_pred.append(‘’.join(map(str, x[x!=10])))</p>
<p>import pandas as pd<br>df_submit = pd.read_csv(‘../input/test_A_sample_submit.csv’)<br>df_submit[‘file_code’] = test_label_pred<br>df_submit.to_csv(‘renset18.csv’, index=None)<br>```</p>
<ul>
<li><h5 id="在训练完成2个Epoch后，模型在测试集上的成绩应该在0-33左右。"><a href="#在训练完成2个Epoch后，模型在测试集上的成绩应该在0-33左右。" class="headerlink" title="在训练完成2个Epoch后，模型在测试集上的成绩应该在0.33左右。"></a>在训练完成2个Epoch后，模型在测试集上的成绩应该在0.33左右。</h5></li>
</ul>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/notes/">notes</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/datawhale/">datawhale</a>
                    
                      <a class="hover-with-bg" href="/tags/Python/">Python</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var post = $('#post');
      var toc = $('#toc');
      var tocLimMax = post.offset().top + post.height() - navHeight;

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = $('#board-ctn').css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>










<!-- Plugins -->


  

  
    <!-- Google Analytics -->
    <script defer>
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-160806707-1', 'auto');
      ga('send', 'pageview');
    </script>
  

  

  

  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Datawhale小组学习之街景字符编码识别任务——Task01：赛题理解&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->












</body>
</html>
