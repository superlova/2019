<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Superlova</title>
  
  <subtitle>Welcome...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://superlova.github.io/"/>
  <updated>2021-05-04T16:25:43.954Z</updated>
  <id>https://superlova.github.io/</id>
  
  <author>
    <name>Superlova</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【学习笔记】数据密集性应用系统设计CH1笔记</title>
    <link href="https://superlova.github.io/2021/05/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E6%80%A7%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1CH1%E7%AC%94%E8%AE%B0/"/>
    <id>https://superlova.github.io/2021/05/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E6%80%A7%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1CH1%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-04T13:23:13.000Z</published>
    <updated>2021-05-04T16:25:43.954Z</updated>
    
    <content type="html"><![CDATA[<p>第一章：可靠、可扩展和可维护的应用系统<br><a id="more"></a></p><h3 id="数据密集型问题的挑战："><a href="#数据密集型问题的挑战：" class="headerlink" title="数据密集型问题的挑战："></a>数据密集型问题的挑战：</h3><p>数据量，数据复杂度，数据的快速多变性；</p><h3 id="数据密集型应用包含以下模块："><a href="#数据密集型应用包含以下模块：" class="headerlink" title="数据密集型应用包含以下模块："></a>数据密集型应用包含以下模块：</h3><ul><li>数据库；</li><li>高速缓存；</li><li>索引：用户可以按关键字搜索数据井支持各种过滤操作；</li><li>流式处理：持续发送消息至另一个进程，处理采用异步方式；</li><li>批处理：定期处理大量累计数据。</li></ul><h3 id="数据系统"><a href="#数据系统" class="headerlink" title="数据系统"></a>数据系统</h3><p>本章提出<strong>数据系统</strong>的概念，包括<strong>数据库</strong>、<strong>消息队列</strong>和<strong>高速缓存</strong>等不同类型的系统。这样分类的原因有以下几点：</p><ol><li><p>都能将数据保存一段时间。区别在于访问模式不同，以及由于不同访问模式导致的不同性能。</p></li><li><p>新技术、工具拥有多种功能，系统之间的界限变得模糊。比如redis既能<strong>存储</strong>也能作为<strong>消息队列</strong>，kafka作为<strong>消息队列</strong>也能<strong>持久化存储</strong>。</p></li><li><p>系统也需要细分，原有的但各组件无法满足数据处理与存储需求，三分类概念需要进一步分解。例如，即便是一个简单的数据系统，也可能由很多子组件构成：</p></li></ol><p><img src="/2021/05/04/【学习笔记】数据密集性应用系统设计CH1笔记/一种数据系统架构.png" srcset="/img/loading.gif" alt></p><p>这个应用包含缓存层（Memcached）和全文索引服务器（Elasticsearch或者Solr）以及数据库。程序员编写应用代码来控制缓存、索引和数据同步操作。</p><h3 id="数据系统的三种关键特性："><a href="#数据系统的三种关键特性：" class="headerlink" title="数据系统的三种关键特性："></a>数据系统的三种关键特性：</h3><ul><li><p>可靠性（Reliability）：当出现意外情况，如软件、硬件故障，人为操作失误等现象时，系统仍可以正常运转的能力。这里的正常运转，是指牺牲部分性能条件下，提供正确的服务。</p></li><li><p>可扩展性（Scalability）：随着问题规模的增长，比如流量、数据量或者任务复杂度，系统以合理方式匹配这种增长的能力。</p></li><li><p>可维护性（Maintainability）：新的开发或者维护人员上手的容易程度，以及适配新场景的能力。</p></li></ul><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>什么是可靠性？即使发生了某些错误，系统仍可以继续正常工作的能力。</p><ul><li>故障或错误（fault）：组件偏离正确规格的现象。</li><li>失效（failure）：系统宕机，无法提供服务。</li></ul><p>为保证可靠性，需要设计容错机制（fault-tolerant）来避免故障引发系统失效，而不是避免故障（当然，避免故障也是提升可靠性的手段）。</p><h3 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h3><h4 id="失效前平均时间（MTTF）"><a href="#失效前平均时间（MTTF）" class="headerlink" title="失效前平均时间（MTTF）"></a>失效前平均时间（MTTF）</h4><p>是针对不可修复系统而言的，是指系统发生失效前的平均工作（或存储） 时间或工作次数。越高越好。</p><h4 id="平均无故障时间（MTBF）"><a href="#平均无故障时间（MTBF）" class="headerlink" title="平均无故障时间（MTBF）"></a>平均无故障时间（MTBF）</h4><p>是针对可修复系统而言的，指两次相邻失效（故障） 之间的工作时间， 而不是指整个系统的报废时间。越高越好。</p><h4 id="平均修复时间（MTTR）"><a href="#平均修复时间（MTTR）" class="headerlink" title="平均修复时间（MTTR）"></a>平均修复时间（MTTR）</h4><p>是对可修复系统而言的，指从出现故障到修复中间的这段时间。越低越好。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>又称为有效性，一般用可用度来定量计算，公式为</p><script type="math/tex; mode=display">A=\frac{\text{MTBF}}{\text{MTBF}+\text{MTTR}}</script><p>可靠性通常低于可用性。对于不可维修系统， 可用度就仅仅决定于且等于可靠度。</p><h3 id="数据系统可能发生哪些故障？如何提升容错能力？"><a href="#数据系统可能发生哪些故障？如何提升容错能力？" class="headerlink" title="数据系统可能发生哪些故障？如何提升容错能力？"></a>数据系统可能发生哪些故障？如何提升容错能力？</h3><h4 id="1-硬件故障"><a href="#1-硬件故障" class="headerlink" title="1. 硬件故障"></a>1. 硬件故障</h4><p>包括硬盘错误、电源错误、网口接触不良等。</p><p>最耐用的硬盘的MTTF为10~50年，因此一个包括10000个磁盘的存储集群中，一天坏一个也是很正常的（假设购买硬盘在时间上是均匀分布）。</p><p>应对方案是添加冗余，比如上述硬盘问题就可以用RAID，电源用双电源，甚至热插拔CPU等。</p><p>以上是从硬件角度解决硬件故障，其实可以通过软件角度解决硬件故障问题。</p><h4 id="2-软件错误"><a href="#2-软件错误" class="headerlink" title="2. 软件错误"></a>2. 软件错误</h4><p>操作系统内核的Bug，系统依赖的服务突然没有响应，某个组件的失控等。</p><p>软件系统的问题有时没有快速解决的办法，只能通过检查依赖假设和系统交互、进行全面测试等方法来预防，或者允许进程重启、评估运行时表现等应对。</p><h4 id="3-人为失误"><a href="#3-人为失误" class="headerlink" title="3. 人为失误"></a>3. 人为失误</h4><p>人是最不可靠的因素。运维人员配置错误往往是系统下线的主要原因。</p><p>这部分的预防以及应对，更加依赖软件工程领域的知识。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>可扩展性是用来描述系统应对负载增加的能力的术语。一个系统添加计算单元越容易，添加计算单元后计算能力的增长越多，就称这个系统的可扩展性越强。</p><h3 id="如何度量系统负载"><a href="#如何度量系统负载" class="headerlink" title="如何度量系统负载"></a>如何度量系统负载</h3><p>每秒请求处理次数、数据库中写入的比例、聊天室的同时活动用户数量、缓存命中率等，</p><p>还要注意分析平均值和峰值对性能的影响</p><h3 id="实例：twitter的两个实现版本"><a href="#实例：twitter的两个实现版本" class="headerlink" title="实例：twitter的两个实现版本"></a>实例：twitter的两个实现版本</h3><p>twitter有两个功能（类比微博，为了方便理解我接下来以微博代替推特），根据其2012年的数据，其功能和负载如下：</p><p>发微博：平均每秒4600条发布申请，峰值12000条推特申请发布。</p><p>收微博：平均每秒300,000条收微博的请求。</p><p>twitter第一个版本使用如下系统设计完成微博的收发：</p><p>发送微博：用户发送的微博插入全局微博集合。</p><p>用户申请查看自己的时间线：  </p><ul><li>遍历所有User的关注对象；</li><li>提取所有关注对象的微博；</li><li>按照发表时间排序并合并。</li></ul><p>随着注册用户变多，负载压力与日俱增，因此采取第二种方法：</p><p>每个用户的时间线维护一个缓存。</p><p>用户发表新的微博：</p><ul><li>查询关注对象；</li><li>插入到每个粉丝的时间线缓存。</li></ul><p>方法二的好处是，用户发布微博时多做一些事情可以加速用户接收微博时的性能。而用户接收微博的请求负载比发送负载高两个数量级。</p><p>Twitter针对那些粉丝量特别多的大V采用方法一，针对粉丝量不太大的绝大多数用户使用方法二。</p><h3 id="如何度量系统性能"><a href="#如何度量系统性能" class="headerlink" title="如何度量系统性能"></a>如何度量系统性能</h3><p><strong>吞吐量</strong></p><p>吞吐量是在一个特定时间段内完成的任务的计数，例如：每秒点击数。</p><p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间</p><p>并发数： 系统同时处理的request/事务数</p><p>TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。</p><p>QPS：每秒查询率，即对一个特定的查询服务器在规定时间内所处理流量大小。</p><p><strong>响应时间</strong></p><p>从客户端发送请求到接受响应之间的间隔时长。在线系统通常更看重响应时间，批处理系统更关心吞吐量。</p><p>由于每次请求的响应时间服从一个分布，因此我们更关心平均响应时长，或者<strong>百分位数时长</strong>。将响应时长排序，取50百分位数（中位数）比平均数更有意义。其他有意义的百分位数有95、99和99.9百分位数。</p><p>采用较高的响应时间百分位数很重要，因为他们直接影响用户的总体服务体验。95百分位数的响应时间为1.5秒，意味着100个请求中5个请求慢于1.5秒，但是对于电商平台来说，有可能恰恰是这些顾客购买了更多的商品导致访问变慢。</p><p>排队延迟是影响高百分数响应时间的主要延迟来源。因此，如果在性能测试时，负载生成客户端在服务器处理完之前请求后再发送新的请求，就会忽视了排队造成的延迟。</p><h3 id="长尾效应"><a href="#长尾效应" class="headerlink" title="长尾效应"></a>长尾效应</h3><p>一个服务涉及多个不同的后端调用，则最慢的调用会拖累整个服务的响应时间，这种现象称之为长尾效应。</p><p>用户总是需要等待最慢的那个调用完成。因此即便只有很小比例的请求缓慢，也可能由于某一个用户频繁产生这种调用而导致总体变慢。</p><h3 id="如何应对负载增加，提升可扩展性？"><a href="#如何应对负载增加，提升可扩展性？" class="headerlink" title="如何应对负载增加，提升可扩展性？"></a>如何应对负载增加，提升可扩展性？</h3><p>垂直扩展：升级到更强大的机器。</p><p>水平扩展：将负载分布到更多小机器。</p><p>系统设计时，要在这两种扩展中间作取舍。同时要根据不同的吞吐量、请求方式等做针对性优化。</p><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><p>软件工程师不喜欢读别人留下的代码，不喜欢维护别人开发的老系统，这已经是众所周知的事实。</p><p>但是换个角度，不如说大多数系统在设计之初就没有考虑令后续开发者方便地维护这一个特性。</p><p>为了提升系统的可维护性，减少维护期间的麻烦，可以遵循软件系统的三个设计原则：</p><p>可运维性、简单性、可演化性。</p><h4 id="可运维性"><a href="#可运维性" class="headerlink" title="可运维性"></a>可运维性</h4><p>目标是令运维人员更轻松。之前讨论过，人是系统中最不稳定的因素。因此简化运维人员的操作，使运维人员能够专注于高附加值的任务，能够提升系统的可维护性。</p><p>可以从以下角度提升可运维性：</p><ul><li>提供系统运行时监控工具，方便监控；</li><li>自动化工具；</li><li>避免绑定特定的机器；</li><li>提供良好的文档；</li><li>提供良好的默认配置；</li><li>尝试自我修复等。</li></ul><h4 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h4><p>简单性是复杂性的反面。而复杂性有各种各样的表现方式，比如模块紧耦合，状态空间膨胀，依赖关系复杂，命名方法混乱，各种性能trick等。</p><p>消除复杂性的最好手段之一是抽象，通过抽象掩盖大量实现细节，提供干净的接口。</p><h4 id="可演化性"><a href="#可演化性" class="headerlink" title="可演化性"></a>可演化性</h4><p>提升可演化性是令系统易于改变的另一种说法。目标是可以轻松地修改数据系统，使其适应不断变化的需求。</p><p>在组织流程方面，敏捷开发模式为适应变化提供了很好的参考。因此敏捷性与可演化性很类似。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一章：可靠、可扩展和可维护的应用系统&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Big Data" scheme="https://superlova.github.io/tags/Big-Data/"/>
    
      <category term="Distributed System" scheme="https://superlova.github.io/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>【论文阅读笔记】MapReduce: Simplified Data Processing on Large Clusters</title>
    <link href="https://superlova.github.io/2021/05/04/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91MapReduce-Simplified-Data-Processing-on-Large-Clusters/"/>
    <id>https://superlova.github.io/2021/05/04/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91MapReduce-Simplified-Data-Processing-on-Large-Clusters/</id>
    <published>2021-05-04T11:27:32.000Z</published>
    <updated>2021-05-04T17:23:10.711Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce是Google提出的一个软件架构，用于大规模数据集的并行运算。<br><a id="more"></a></p><p>本文描述了MapReduce框架，该框架为大规模的分布式计算和自动化并行计算带来简单的接口。</p><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MapReduce是Google提出的一个软件架构，用于大规模数据集的并行运算。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="paper" scheme="https://superlova.github.io/categories/paper/"/>
    
    
      <category term="Big Data" scheme="https://superlova.github.io/tags/Big-Data/"/>
    
      <category term="Distributed System" scheme="https://superlova.github.io/tags/Distributed-System/"/>
    
      <category term="MapReduce" scheme="https://superlova.github.io/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Hadoop介绍和安装</title>
    <link href="https://superlova.github.io/2021/05/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Hadoop%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <id>https://superlova.github.io/2021/05/04/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Hadoop%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85/</id>
    <published>2021-05-04T11:26:57.000Z</published>
    <updated>2021-05-04T17:17:18.310Z</updated>
    
    <content type="html"><![CDATA[<p>Hadoop学习笔记第一篇。<br><a id="more"></a></p><h1 id="Hadoop介绍"><a href="#Hadoop介绍" class="headerlink" title="Hadoop介绍"></a>Hadoop介绍</h1><p>Apache Hadoop 软件库是一个框架，允许在<strong>集群服务器</strong>上使用简单的<strong>编程模型</strong>，<strong>对大数据集进行分布式处理</strong>。</p><p>Hadoop 可扩展性强，能从单台服务器扩展到数以千计的服务器；Hadoop 高可用，其代码库自身就能在应用层侦测并处理硬件故障。</p><p>Hadoop 的生态系统不仅包含 Hadoop，而且还包含 HDFS、HBase等基本组件。</p><p><img src="/2021/05/04/【学习笔记】Hadoop介绍和安装/Hadoop生态系统.png" srcset="/img/loading.gif" alt></p><p><strong>HDFS (Hadoop Distributed File System)</strong></p><p>HDFS是分布式文件系统的一种。HDFS是Hadoop生态系统的基本组成，它将数据保存在计算机集群上。HDFS是HBase等工具的基础。</p><p><strong>MapReduce</strong></p><p>MapReduce是一种分布式计算框架，也是一个分布式、并行处理的编程模型。MapReduce把任务分为<code>map</code>阶段和<code>reduce</code>阶段，<code>map</code>阶段将任务分解成子任务后映射到集群上，<code>reduce</code>将结果化简并整合。</p><p>正是利用了MapReduce的工作特性，Hadoop因此能以并行的方式访问数据，从而实现分布式计算。</p><p>关于MapReduce的论文讲解，请看TODO。</p><p><strong>HBase</strong></p><p>HBase 是一个建立在 HDFS 之上，面向列的 NoSQL 数据库，用于快速读 / 写大量数据。HBase 使用 Zookeeper 进行管理。</p><p><strong>ZooKeeper</strong></p><p>ZooKeeper 为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。</p><p>Hadoop 的许多组件依赖于 Zookeeper，它运行在计算机集群中，用于管理 Hadoop 集群。</p><p><strong>Pig</strong></p><p>Pig是一个基于Hadoop的大规模数据分析平台，它为 MapReduce 编程模型提供了一个简单的操作和编程接口。它提供的SQL-LIKE语言叫Pig Latin，该语言的编译器会把类SQL的数据分析请求转换为一系列经过优化处理的MapReduce运算。</p><p><strong>Hive</strong><br>Apache Hive是一个建立在Hadoop架构之上的数据仓库。它能够提供数据的精炼，查询和分析。像 Pig 一样，Hive 作为一个抽象层工具，吸引了很多熟悉 SQL 而不是 Java 编程的数据分析师。</p><p>与Pig的区别在于，Pig是一中编程语言，使用命令式操作加载数据、表达转换数据以及存储最终结果。Pig中没有表的概念。而Hive更像是SQL，使用类似于SQL语法进行数据查询。</p><p><strong>Sqoop</strong></p><p>用于在关系数据库、数据仓库和 Hadoop 之间转移数据。</p><p><strong>Flume</strong></p><p>是一个分布式、可靠、高可用的海量日志采集、聚合和传输的系统，用于有效地收集、聚合和将大量日志数据从许多不同的源移动到一个集中的数据存储（如文本、HDFS、Hbase等）。</p><p><strong>Yarn</strong></p><p>是从Hadoop 2.0版本开始沿用的任务调度和集群资源管理的框架。</p><p><strong>Spark</strong></p><p>一个快速通用的 Hadoop 数据计算引擎，具有简单和富有表达力的编程模型，支持数据 ETL（提取、转换和加载）、机器学习、流处理和图形计算等方面的应用。</p><p>Spark 这一分布式内存计算框架就是脱胎于 Hadoop 体系的，它对 HDFS 、YARN 等组件有了良好的继承，同时也改进了 Hadoop 现存的一些不足。</p><p>下图是Hadoop集群的基本架构。</p><p><img src="/2021/05/04/【学习笔记】Hadoop介绍和安装/Hadoop集群基本架构.png" srcset="/img/loading.gif" alt></p><h1 id="Hadoop-可以做什么"><a href="#Hadoop-可以做什么" class="headerlink" title="Hadoop 可以做什么"></a>Hadoop 可以做什么</h1><p>据Hadoop Wiki记载，阿里巴巴使用15个节点组成的Hadoop集群，每个节点拥有8核心、16GB内存和1.4TB存储。阿里巴巴使用这些节点来处理商业数据的排序和组合，应用于交易网站的垂直搜索。</p><p>Ebay拥有32个节点组成的集群，使用Java编写的MapReduce应用，来优化搜索引擎。</p><p>FaceBook使用Hadoop来存储内部日志和结构化数据源副本，并且将其作为数据报告、数据分析和机器学习的数据源。</p><h1 id="Hadoop-不同版本"><a href="#Hadoop-不同版本" class="headerlink" title="Hadoop 不同版本"></a>Hadoop 不同版本</h1><p><strong>关于发行方：</strong></p><p>目前Hadoop发行版非常多，有Intel发行版，华为发行版、Cloudera发行版（CDH）、Hortonworks版本等，所有这些发行版均是基于Apache Hadoop衍生出来的，之所以有这么多的版本，是由于Apache Hadoop的开源协议决定的：任何人可以对其进行修改，并作为开源或商业产品发布/销售。</p><p><strong>关于版本：</strong></p><p>现在最新的Hadoop已经达到3.X了，然而大部分公司使用Hadoop 2.X。又由于Hadoop 2.X与1.X相比有较大变化，因此直接使用2.X是比较合理的选择。</p><p>Hadoop2.0新增了HDFS HA机制，HA增加了standbynamenode进行热备份，解决了1.0的单点故障问题。</p><p>Hadoop2.0新增了HDFS federation，解决了HDFS水平可扩展能力。 </p><p>2.0相比于1.0 新增了YARN框架，Mapreduce的运行环境发生了变化</p><h1 id="Hadoop-安装"><a href="#Hadoop-安装" class="headerlink" title="Hadoop 安装"></a>Hadoop 安装</h1><p>Hadoop有三种安装方式</p><ul><li>单机模式：安装简单，几乎不用做任何配置，但仅限于调试用途。</li><li>伪分布模式：在单节点上同时启动 NameNode、DataNode、JobTracker、TaskTracker、Secondary Namenode 等 5 个进程，模拟分布式运行的各个节点。</li><li>完全分布式模式：正常的 Hadoop 集群，由多个各司其职的节点构成。</li></ul><p>本文介绍 Hadoop 伪分布式模式部署方法，Hadoop 版本为 2.6.1。</p><h2 id="1-设置用户和组"><a href="#1-设置用户和组" class="headerlink" title="1. 设置用户和组"></a>1. 设置用户和组</h2><pre><code>sudo adduser hadoopsudo usermod -G sudo hadoop</code></pre><h2 id="2-安装JDK"><a href="#2-安装JDK" class="headerlink" title="2. 安装JDK"></a>2. 安装JDK</h2><p>不同版本的 Hadoop 对 Java 的版本需求有细微的差别，可以在<a href="https://cwiki.apache.org/confluence/display/HADOOP2/HadoopJavaVersions" target="_blank" rel="noopener">这个网站</a>查询 Hadoop 版本与 Java 版本的关系。</p><p>测试jdk是否部署成功：</p><pre><code class="lang-sh">java -version</code></pre><h2 id="3-配置SSH免密码登录"><a href="#3-配置SSH免密码登录" class="headerlink" title="3. 配置SSH免密码登录"></a>3. 配置SSH免密码登录</h2><p>安装和配置 SSH 的目的是为了让 Hadoop 能够方便地运行远程管理守护进程的相关脚本。这些脚本需要用到 sshd 服务。</p><pre><code class="lang-sh">su hadoopcd /home/hadoopssh-keygen -t rsa# 将生成的公钥添加到主机认证记录中。cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys# 为 authorized_keys 文件赋予写权限chmod 600 .ssh/authorized_keys# 尝试登录到本机ssh localhost</code></pre><h2 id="4-下载-Hadoop"><a href="#4-下载-Hadoop" class="headerlink" title="4. 下载 Hadoop"></a>4. 下载 Hadoop</h2><pre><code class="lang-sh">wget https://archive.apache.org/dist/hadoop/common/hadoop-2.6.1/hadoop-2.6.1.tar.gztar zxvf hadoop-2.6.1.tar.gzsudo mv hadoop-2.6.1 /opt/hadoop-2.6.1sudo chown -R hadoop:hadoop /opt/hadoop-2.6.1vim /home/hadoop/.bashrc</code></pre><p>在 /home/hadoop/.bashrc 文件的末尾添加以下内容：</p><pre><code class="lang-sh">export HADOOP_HOME=/opt/hadoop-2.6.1export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</code></pre><p>在终端中输入 source 命令来激活新添加的环境变量。</p><pre><code class="lang-sh">source /home/hadoop/.bashrc</code></pre><h2 id="5-伪分布式模式配置"><a href="#5-伪分布式模式配置" class="headerlink" title="5. 伪分布式模式配置"></a>5. 伪分布式模式配置</h2><p>Hadoop 还可以以伪分布式模式运行在单个节点上，通过多个独立的 Java 进程来模拟多节点的情况。在初始学习阶段，暂时没有必要耗费大量的资源来创建不同的节点。</p><p>5.1 <strong>打开 core-site.xml 文件:</strong></p><pre><code class="lang-sh">vim /opt/hadoop-2.6.1/etc/hadoop/core-site.xml</code></pre><p>将 configuration 标签的值修改为以下内容：</p><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;fs.defaultFS&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>fs.defaultFS 配置项用于指示集群默认使用的文件系统的位置。</p><p>5.2 <strong>打开另一个配置文件 hdfs-site.xml</strong></p><pre><code class="lang-sh">vim /opt/hadoop-2.6.1/etc/hadoop/hdfs-site.xml</code></pre><p>将 configuration 标签的值修改为以下内容：</p><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.replication&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>该配置项用于指示 HDFS 中文件副本的数量，默认情况下是 3 份，由于我们在单台节点上以伪分布式的方式部署，所以将其修改为 1 。</p><p>5.3 <strong>编辑 hadoop-env.sh 文件：</strong></p><pre><code class="lang-sh">vim /opt/hadoop-2.6.1/etc/hadoop/hadoop-env.sh</code></pre><p>将其中 <code>export JAVA_HOME</code> 的值修改为 JDK 的实际位置，即 <code>/usr/lib/jvm/java-8-oracle</code> 。</p><p>5.4 <strong>编辑 yarn-site.xml 文件：</strong></p><pre><code class="lang-sh">vim /opt/hadoop-2.6.1/etc/hadoop/yarn-site.xml</code></pre><p>在 configuration 标签内添加以下内容：</p><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><p>5.5 <strong>编辑 mapred-site.xml 文件。首先需要从模板复制过来：</strong></p><pre><code class="lang-sh">cp /opt/hadoop-2.6.1/etc/hadoop/mapred-site.xml.template /opt/hadoop-2.6.1/etc/hadoop/mapred-site.xmlvim /opt/hadoop-2.6.1/etc/hadoop/mapred-site.xml</code></pre><p>在 configuration 标签内添加以下内容：</p><pre><code class="lang-xml">&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;        &lt;value&gt;yarn&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;</code></pre><h2 id="6-Hadoop-启动测试"><a href="#6-Hadoop-启动测试" class="headerlink" title="6. Hadoop 启动测试"></a>6. Hadoop 启动测试</h2><pre><code class="lang-sh">su -l hadoopvim /home/hadoop/.bashrc</code></pre><p>向<code>.bashrc</code>添加 Java 的环境变量：</p><pre><code class="lang-sh">export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport PATH=$PATH:$JAVA_HOME/bin</code></pre><h1 id="HDFS-的基本使用"><a href="#HDFS-的基本使用" class="headerlink" title="HDFS 的基本使用"></a>HDFS 的基本使用</h1><h2 id="1-初始化HDFS"><a href="#1-初始化HDFS" class="headerlink" title="1. 初始化HDFS"></a>1. 初始化HDFS</h2><pre><code class="lang-sh">hdfs namenode -format</code></pre><p>格式化的操作只需要进行一次即可，不需要多次格式化。每一次格式化 namenode 都会清除 HDFS 分布式文件系统中的所有数据文件。同时，多次格式化容易出现 namenode 和 datanode 不同步的问题。</p><h2 id="2-启动HDFS"><a href="#2-启动HDFS" class="headerlink" title="2. 启动HDFS"></a>2. 启动HDFS</h2><p>HDFS 初始化完成之后，就可以启动 NameNode 和 DataNode 的守护进程。启动之后，Hadoop 的应用（如 MapReduce 任务）就可以从 HDFS 中读写文件。</p><p>在终端中输入以下命令来启动守护进程：</p><pre><code class="lang-sh">start-dfs.sh</code></pre><p>为了确认伪分布式模式下的 Hadoop 已经成功运行，可以利用 Java 的进程查看工具 <code>jps</code> 来查看是否有相应的进程。</p><p>如果执行 jps 发现没有 NameNode 服务进程，可以先检查一下是否执行了 namenode 的初始化操作。如果没有初始化 namenode ，先执行 stop-dfs.sh ,然后执行 hdfs namenode -format ,最后执行 start-dfs.sh 命令，通常来说这样就能够保证这三个服务进程成功启动</p><h2 id="3-查看日志和WebUI"><a href="#3-查看日志和WebUI" class="headerlink" title="3. 查看日志和WebUI"></a>3. 查看日志和WebUI</h2><p>作为大数据领域的学习者，掌握分析日志的能力与学习相关计算框架的能力同样重要。</p><p>Hadoop 的守护进程日志默认输出在安装目录的 log 文件夹中，在终端中输入以下命令进入到日志目录：</p><pre><code class="lang-sh">cd /opt/hadoop-2.6.1/logsls</code></pre><p>HDFS 在启动完成之后，还会由内部的 Web 服务提供一个查看集群状态的网页：</p><p><a href="http://localhost:50070/" target="_blank" rel="noopener">http://localhost:50070/</a></p><p>打开网页后，可以在其中查看到集群的概览、DataNode 的状态等信息。</p><h2 id="4-HDFS文件上传测试"><a href="#4-HDFS文件上传测试" class="headerlink" title="4. HDFS文件上传测试"></a>4. HDFS文件上传测试</h2><p>HDFS 运行起来之后，可将其视作一个文件系统。此处进行文件上传的测试，首先需要按照目录层级逐个创建目录，并尝试将 Linux 系统中的一些文件上传到 HDFS 中。</p><pre><code class="lang-sh">cd ~hdfs dfs -mkdir /userhdfs dfs -mkdir /user/hadoop</code></pre><p>如果需要查看创建好的文件夹，可以使用如下命令：</p><pre><code class="lang-sh">hdfs dfs -ls /user</code></pre><p>目录创建成功之后，使用 <code>hdfs dfs -put</code> 命令将本地磁盘上的文件（此处是随意选取的 Hadoop 配置文件）上传到 HDFS 之中。</p><pre><code class="lang-sh">hdfs dfs -put /opt/hadoop-2.6.1/etc/hadoop /user/hadoop/input</code></pre><p>如果要查看上传的文件，可以执行如下命令：</p><pre><code class="lang-sh">hdfs dfs -ls /user/hadoop/input</code></pre><h1 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h1><p>WordCount 是 Hadoop 的 “HelloWorld” 程序。</p><p>绝大多数部署在实际生产环境并且解决实际问题的 Hadoop 应用程序都是基于 WordCount 所代表的 MapReduce 编程模型变化而来。</p><p>在终端中首先启动 YARN 计算服务：</p><pre><code class="lang-sh">start-yarn.sh</code></pre><p>然后输入以下命令以启动任务</p><pre><code class="lang-sh">hadoop jar /opt/hadoop-2.6.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.1.jar wordcount /user/hadoop/input/ output</code></pre><p>上述参数中，关于路径的参数有三个，分别是 jar 包的位置、输入文件的位置和输出结果的存放位置。在填写路径时，应当养成填写绝对路径的习惯。这样做将有利于定位问题和传递工作。</p><p>等待计算完成，然后将 HDFS 上的文件导出到本地目录查看：</p><pre><code class="lang-sh">rm -rf /home/hadoop/outputhdfs dfs -get /user/hadoop/output outputcat output/*</code></pre><p>计算完毕后，如无其他软件需要使用 HDFS 上的文件，则应及时关闭 HDFS 守护进程。</p><p>作为分布式集群和相关计算框架的使用者，应当养成良好的习惯，在每次涉及到集群开启和关闭、软硬件安装和更新的时候，都主动检查相关软硬件的状态。</p><pre><code class="lang-sh">stop-yarn.shstop-dfs.sh</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop学习笔记第一篇。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Hadoop" scheme="https://superlova.github.io/tags/Hadoop/"/>
    
      <category term="Big Data" scheme="https://superlova.github.io/tags/Big-Data/"/>
    
      <category term="Distributed System" scheme="https://superlova.github.io/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】计算二进制中1的个数</title>
    <link href="https://superlova.github.io/2021/05/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://superlova.github.io/2021/05/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2021-05-03T06:30:06.000Z</published>
    <updated>2021-05-03T09:30:24.705Z</updated>
    
    <content type="html"><![CDATA[<p>二进制中1的个数的两种计算方法</p><a id="more"></a><p>第一种解法，<code>n &amp;= (n - 1);</code>这一句消灭了二进制末尾的1。循环次数与二进制中1的个数相同。</p><pre><code class="lang-cpp">int hammingWeight(uint32_t n) {    int count = 0;    while (n != 0) {        n &amp;= (n - 1);        ++count;    }    return count;}</code></pre><p>第二种解法，是把性能挖掘到极致的解法：</p><pre><code class="lang-cpp">size_t hammingWeight(uint64_t V) {    V -= ((V &gt;&gt; 1) &amp; 0x5555555555555555); // 010101010101    V = (V &amp; 0x3333333333333333) + ((V &gt;&gt; 2) &amp; 0x3333333333333333);    return ((V + (V &gt;&gt; 4) &amp; 0xF0F0F0F0F0F0F0F) * 0x101010101010101) &gt;&gt; 56;}</code></pre><p>只依靠位运算，不进行条件判断，方便并行计算。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制中1的个数的两种计算方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="leetcode" scheme="https://superlova.github.io/tags/leetcode/"/>
    
      <category term="binary" scheme="https://superlova.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>【竞赛打卡】不限精度的大整数表示</title>
    <link href="https://superlova.github.io/2021/05/03/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E4%B8%8D%E9%99%90%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <id>https://superlova.github.io/2021/05/03/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E4%B8%8D%E9%99%90%E7%B2%BE%E5%BA%A6%E7%9A%84%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/</id>
    <published>2021-05-03T06:27:43.000Z</published>
    <updated>2021-05-03T09:25:22.107Z</updated>
    
    <content type="html"><![CDATA[<p>两个大整数相乘，如何在不损失精度的前提下计算得到正确的结果？<br><a id="more"></a></p><h1 id="不限精度的整数运算"><a href="#不限精度的整数运算" class="headerlink" title="不限精度的整数运算"></a>不限精度的整数运算</h1><p>前一篇文章我们讨论了两个64位整数的乘法，本篇文章我们讨论高精度数值的加减运算问题。</p><h2 id="大整数存储"><a href="#大整数存储" class="headerlink" title="大整数存储"></a>大整数存储</h2><p>很简单，使用数组即可。注意整数的高位存储在数组的末尾，整数的低位存储在数组的开头。</p><pre><code class="lang-py"># 235813d[0] = 3d[1] = 1d[2] = 8d[3] = 5d[4] = 3d[5] = 2</code></pre><p>这样做的原因是，四则运算一般是从低位向高位计算的，数组则是从0开始遍历的。不过如果数字以字符串存储则不然。比如<code>s=&quot;235813&quot;</code>这个字符串的存储顺序和逻辑顺序恰恰相反。</p><pre><code class="lang-cpp">class BigInt {public:    int d[1000]{};    int len;    BigInt() {        memset(d, 0, sizeof(d));        len = 0;    }    static BigInt change(std::string str);    static int compare(BigInt a, BigInt b);    static BigInt add(BigInt a, BigInt b);    static BigInt sub(BigInt a, BigInt b);};</code></pre><p>输入大整数时，一般都以<code>string</code>类型输入，因此需要执行<code>reverse</code>操作，或者直接逆序赋值。</p><h2 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><pre><code class="lang-cpp">BigInt BigInt::add(BigInt a, BigInt b) {    BigInt c;    int carry = 0;    for (int i = 0; i &lt; a.len || i &lt; b.len; ++i) {        int temp = a.d[i] + b.d[i] + carry;        c.d[c.len++] = temp % 10;        carry = temp / 10;    }    if (carry != 0) {        c.d[c.len++] = carry;    }    return c;}</code></pre><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><pre><code class="lang-cpp">BigInt BigInt::sub(BigInt a, BigInt b) {    BigInt c;    for (int i = 0; i &lt; a.len || i &lt; b.len; ++i) {        if (a.d[i] &lt; b.d[i]) {            a.d[i+1]--;            a.d[i] += 10; // 借位        }        c.d[c.len++] = a.d[i] - b.d[i];    }    while (c.len - 1 &gt;= 1 &amp;&amp; c.d[c.len - 1] == 0) {        c.len--;    }    return c;}</code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><pre><code class="lang-cpp">int BigInt::compare(BigInt a, BigInt b) {    if (a.len &gt; b.len) return 1;    else if (a.len &lt; b.len) return -1;    else {        for (int i = a.len-1; i &gt;= 0; --i) {            if (a.d[i] &gt; b.d[i]) return 1;            else if (a.d[i] &lt; b.d[i]) return -1;        }        return 0;    }}</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>算法笔记 5.6 节</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个大整数相乘，如何在不损失精度的前提下计算得到正确的结果？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="algorithm" scheme="https://superlova.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="https://superlova.github.io/tags/leetcode/"/>
    
      <category term="searching" scheme="https://superlova.github.io/tags/searching/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】在 Clion 中使用 Google Test</title>
    <link href="https://superlova.github.io/2021/05/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8-Clion-%E4%B8%AD%E4%BD%BF%E7%94%A8-Google-Test/"/>
    <id>https://superlova.github.io/2021/05/01/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8-Clion-%E4%B8%AD%E4%BD%BF%E7%94%A8-Google-Test/</id>
    <published>2021-05-01T00:41:43.000Z</published>
    <updated>2021-05-01T03:01:55.385Z</updated>
    
    <content type="html"><![CDATA[<p>Google Test 是著名的 C++ 单元测试框架。如何在 CLion中使用 Google Test？<br><a id="more"></a></p><h1 id="1-下载和安装"><a href="#1-下载和安装" class="headerlink" title="1. 下载和安装"></a>1. 下载和安装</h1><p>首先去<a href="https://github.com/google/googletest" target="_blank" rel="noopener">这个网站</a>下载 google test 最新版本。</p><p><img src="/2021/05/01/【学习笔记】在-Clion-中使用-Google-Test/readme.png" srcset="/img/loading.gif" alt></p><p>笔者写作时， google test 的版本为 1.10。</p><p>然后下载最新版本的压缩文件。</p><p><img src="/2021/05/01/【学习笔记】在-Clion-中使用-Google-Test/download.png" srcset="/img/loading.gif" alt></p><p>解压得到文件夹<code>googletest-release-1.10.0</code>，打开文件夹后，把<code>googletest</code>文件夹复制到你的目标工程目录。</p><p><img src="/2021/05/01/【学习笔记】在-Clion-中使用-Google-Test/googletestdir.png" srcset="/img/loading.gif" alt></p><p><img src="/2021/05/01/【学习笔记】在-Clion-中使用-Google-Test/putitinproject.png" srcset="/img/loading.gif" alt></p><p>还没结束，我们需要修改工程根目录的<code>CMakeLists.txt</code>，以使 google test 生效。注意不要修改<code>googletest/CMakeLists.txt</code>！</p><p>向<code>CMakeLists.txt</code>添加如下代码：</p><pre><code class="lang-sh">add_subdirectory(./googletest)include_directories(${PROJECT_SOURCE_DIR}/src/include ./googletest/include)link_directories(${PROJECT_SOURCE_DIR}/lib ${PROJECT_SOURCE_DIR}/googletest)target_link_libraries(${PROJECT_NAME} gtest)</code></pre><p>如果我们想要使用 google test，就在任意cpp文件添加头<code>#include &quot;gtest/gtest.h&quot;</code></p><h1 id="2-简单的用例"><a href="#2-简单的用例" class="headerlink" title="2. 简单的用例"></a>2. 简单的用例</h1><p>做一个简单的测试，我编写了一个将<code>unsigned long long</code>转为二进制数据的函数<code>ulld_to_b</code>，该函数能将一个无符号64位整数转换为64位长的二进制字符串。</p><pre><code class="lang-cpp">string ulld_to_b(uint64_t i) {    return bitset&lt;64&gt;(i).to_string();}</code></pre><p>现在对其进行测试。测试用例为18，我的预期结果为10010，但是前面应该补零至64位长：</p><pre><code class="lang-cpp">TEST(TestCase, test1) {    EXPECT_STREQ(&quot;10010&quot;, ulld_to_b(18ULL).c_str());}TEST(TestCase, test2) {    EXPECT_STREQ(&quot;00000000000000000000000000010010&quot;, ulld_to_b(18ULL).c_str());}TEST(TestCase, test3) {    EXPECT_STREQ(&quot;0000000000000000000000000000000000000000000000000000000000010010&quot;, ulld_to_b(18ULL).c_str());}</code></pre><p>写完测试用例后，需要改造下<code>main()</code>使其运行所有测试用例：</p><pre><code class="lang-cpp">int main(int argc, char** argv) {    testing::InitGoogleTest(&amp;argc, argv);    return RUN_ALL_TESTS();}</code></pre><p>预期结果为前两个测试用例不通过，后一个测试用例通过。</p><p>编译运行后结果如下，完全符合我们的预期：</p><p><img src="/2021/05/01/【学习笔记】在-Clion-中使用-Google-Test/results.png" srcset="/img/loading.gif" alt></p><p>当然这里的使用是不恰当的，我们应当尽可能令所有单元测试都通过。</p><p>在CLion的代码编辑器中可以方便地查看出错的测试用例：</p><p><img src="/2021/05/01/【学习笔记】在-Clion-中使用-Google-Test/result_wrong.png" srcset="/img/loading.gif" alt></p><h1 id="3-批量开关测试用例"><a href="#3-批量开关测试用例" class="headerlink" title="3. 批量开关测试用例"></a>3. 批量开关测试用例</h1><p>在大型工程中，项目上线前需要关闭所有测试用例，逐个删除未免显得笨拙。这个时候我们可以使用宏定义。</p><p>首先将<code>googletest</code>的头文件放在一个统一的头文件<code>stdafx.h</code>中，然后以<code>#ifdef</code>包裹起来：</p><pre><code class="lang-cpp">#ifndef LEETCODE_2021_STDAFX_H#define LEETCODE_2021_STDAFX_H#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;memory&gt;#include &lt;bitset&gt;// 开启测试模式#define DEBUG_MODE#ifdef DEBUG_MODE#include &quot;gtest/gtest.h&quot;#endif#endif //LEETCODE_2021_STDAFX_H</code></pre><p>如果我把<code>#define DEBUG_MODE</code>删除的话，<code>#include &quot;gtest/gtest.h&quot;</code>就不会执行了。</p><p>然后回到每个函数实现处，我们在这里写了很多的测试用例，以及修改了<code>main()</code>函数。同样将它们用<code>#ifdef</code>包裹起来：</p><pre><code class="lang-cpp">#ifdef DEBUG_MODETEST(TestCase, test1) {    EXPECT_STREQ(&quot;10010&quot;, ulld_to_b(18ULL).c_str());}TEST(TestCase, test2) {    EXPECT_STREQ(&quot;00000000000000000000000000010010&quot;, ulld_to_b(18ULL).c_str());}TEST(TestCase, test3) {    EXPECT_STREQ(&quot;0000000000000000000000000000000000000000000000000000000000010010&quot;, ulld_to_b(18ULL).c_str());}#endif</code></pre><p>这些测试用例会随着<code>&quot;stdafx.h&quot;</code>中<code>#define DEBUG_MODE</code>语句的删除而失效。</p><p>最后来看看<code>main()</code>函数如何处理：</p><pre><code class="lang-cpp">#ifndef DEBUG_MODEint main() {    /*...*/    return 0;}#elseint main(int argc, char** argv) {    testing::InitGoogleTest(&amp;argc, argv);    return RUN_ALL_TESTS();}#endif</code></pre><p>如果没定义<code>DEBUG_MODE</code>，则执行正常的<code>main()</code>；否则执行所有测试用例的<code>main(int argc, char** argv)</code>。</p><p>在项目需要上线时，把<code>#define DEBUG_MODE</code>那一行删除即可。</p><h1 id="4-测试用例编写"><a href="#4-测试用例编写" class="headerlink" title="4. 测试用例编写"></a>4. 测试用例编写</h1><h2 id="4-1-EXPECT和ASSERT"><a href="#4-1-EXPECT和ASSERT" class="headerlink" title="4.1 EXPECT和ASSERT"></a>4.1 <code>EXPECT</code>和<code>ASSERT</code></h2><p>google test 使用 TEST 宏声明测试用例。TEST() 有两个参数，<code>TestCaseName</code>，<code>TestName</code>。</p><p>我们之前使用了<code>EXPECT_STREQ</code>这个宏，其含义为验证内部的两个参数为相同的字符串。除此之外，还有很多以EXPECT开头的宏，它们功能各不相同，比如<code>EXPECT_EQ</code>这个宏比较两个数字是否相等。</p><p>EXPECT系列和ASSERT系列的区别是，EXPECT失败后，继续往下执行；ASSERT失败则直接终止程序。</p><p>EXPECT和ASSERT的返回是一个流对象，这意味着我们可以在之后使用<code>&lt;&lt;</code>运算符输出额外信息：</p><pre><code class="lang-cpp">for (int i = 0; i &lt; x.size(); ++i) {    EXPECT_EQ(x[i], y[i]) &lt;&lt; &quot;Vectors x and y differ at index &quot; &lt;&lt; i;}</code></pre><h2 id="4-2-各种不同的宏断言"><a href="#4-2-各种不同的宏断言" class="headerlink" title="4.2 各种不同的宏断言"></a>4.2 各种不同的宏断言</h2><p>本节只列出了<code>ASSERT</code>，实际上每个<code>ASSERT</code>对应一个<code>EXPECT</code>版本。</p><p><strong>编写测试用例时，如果有两个参数，注意把待测函数输出放在后面！前面的参数是Ground Truth，也就是答案。</strong></p><h3 id="布尔值断言，只有一个参数，参数只能为true或者false："><a href="#布尔值断言，只有一个参数，参数只能为true或者false：" class="headerlink" title="布尔值断言，只有一个参数，参数只能为true或者false："></a>布尔值断言，只有一个参数，参数只能为true或者false：</h3><pre><code class="lang-cpp">ASSERT_TRUE(condition)ASSERT_FALSE(condition)</code></pre><h3 id="数值断言："><a href="#数值断言：" class="headerlink" title="数值断言："></a>数值断言：</h3><pre><code class="lang-cpp">ASSERT_EQ(v1, v2) // v1 == v2ASSERT_NE(v1, v2) // v1 != v2ASSERT_LT(v1, v2) // v1 &lt; v2ASSERT_LE(v1, v2) // v1 &lt;= v2ASSERT_GT(v1, v2) // v1 &gt; v2ASSERT_GE(v1, v2) // v1 &gt;= v2</code></pre><h3 id="字符串断言"><a href="#字符串断言" class="headerlink" title="字符串断言"></a>字符串断言</h3><p>这里的参数为C风格字符串，因此当参数为<code>string</code>类型时，你需要调用<code>c_str()</code>方法。</p><pre><code class="lang-cpp">ASSERT_STREQ(s1, s2) // s1和s2内容相同ASSERT_STRNE(s1, s2) // s1和s2内容不同ASSERT_STRCASEEQ(s1, s2) // 忽略大小写，s1和s2内容相同ASSERT_STRCASENE(s1, s2) // 忽略大小写，s1和s2内容不同</code></pre><h3 id="断言返回成功或者失败"><a href="#断言返回成功或者失败" class="headerlink" title="断言返回成功或者失败"></a>断言返回成功或者失败</h3><pre><code class="lang-cpp">TEST(ExplicitTest, Demo){    ADD_FAILURE() &lt;&lt; &quot;Sorry&quot;; // None Fatal Asserton，继续往下执行。    FAIL(); // Fatal Assertion，不往下执行该案例。    SUCCEED();}</code></pre><h3 id="抛出异常的断言"><a href="#抛出异常的断言" class="headerlink" title="抛出异常的断言"></a>抛出异常的断言</h3><pre><code class="lang-cpp">int Foo(int a, int b){    if (a == 0 || b == 0)    {        throw &quot;don&#39;t do that&quot;;    }    int c = a % b;    if (c == 0)        return b;    return Foo(b, c);}TEST(FooTest, HandleZeroInput){    EXPECT_ANY_THROW(Foo(10, 0)); // Foo应当抛出异常    EXPECT_THROW(Foo(0, 5), char*); // Foo应当抛出字符串类型的异常    EXPECT_NO_THROW(Foo(1, 1)); // Foo不应该抛出异常}</code></pre><h3 id="浮点数断言"><a href="#浮点数断言" class="headerlink" title="浮点数断言"></a>浮点数断言</h3><pre><code class="lang-cpp">ASSERT_FLOAT_EQ(exp, act) // 检验两个浮点数是否**几乎**相等ASSERT_DOUBLE_EQ(exp, act) // 同上，只不过精度更高ASSERT_NEAR(exp, act, abs_error) // exp和act之间的差值不会超过abs_error</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html" target="_blank" rel="noopener">https://www.cnblogs.com/coderzh/archive/2009/04/06/1426755.html</a></p><p><a href="https://blog.csdn.net/zhizhengguan/article/details/110313265" target="_blank" rel="noopener">https://blog.csdn.net/zhizhengguan/article/details/110313265</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google Test 是著名的 C++ 单元测试框架。如何在 CLion中使用 Google Test？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="clion" scheme="https://superlova.github.io/tags/clion/"/>
    
      <category term="google test" scheme="https://superlova.github.io/tags/google-test/"/>
    
      <category term="unit test" scheme="https://superlova.github.io/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>【竞赛打卡】大整数相乘 I</title>
    <link href="https://superlova.github.io/2021/04/28/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E4%B9%98/"/>
    <id>https://superlova.github.io/2021/04/28/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E4%B9%98/</id>
    <published>2021-04-28T06:49:39.000Z</published>
    <updated>2021-05-03T06:27:19.213Z</updated>
    
    <content type="html"><![CDATA[<p>两个大整数相乘，如何在不损失精度的前提下计算得到正确的结果？<br><a id="more"></a></p><h1 id="unsigned-long-long-整数之间的乘法"><a href="#unsigned-long-long-整数之间的乘法" class="headerlink" title="unsigned long long 整数之间的乘法"></a><code>unsigned long long</code> 整数之间的乘法</h1><h2 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1. 问题引入"></a>1. 问题引入</h2><p>如果我们使用 <code>C++</code> 语言，在 64 位系统上，<code>unsigned long long</code> 类型（或者 <code>uint64_t</code> 类型）的变量能够保存的数值范围是 $\left[0,2^{64}\right)$。任何小于该数值的数字都能被正确存储。</p><script type="math/tex; mode=display">2^{64}-1=18,446,744,073,709,551,615</script><p>这个十进制的整数足足有20位，一般情况下我们是不需要考虑溢出问题的。</p><p>但是如果两个<code>uint64_t</code>的变量要做乘法，就必须考虑溢出问题了。因为两个64位整数相乘，其结果可能达到128位，超过了一个变量能存储的数据的极限大小。</p><p>两个<code>uint64_t</code>变量的乘法该如何正确计算？考虑极端情况，两个<code>uint64_t</code>整数所能表达的最大数字<code>UINT_MAX</code>相乘：</p><script type="math/tex; mode=display">(2^{64}-1)\times (2^{64}-1)=2^{128}-2^{65}+1</script><p>这里面最大的数字是$2^{128}$，因此我们最极端情况下有128位的信息需要保存。</p><h2 id="2-问题简化"><a href="#2-问题简化" class="headerlink" title="2. 问题简化"></a>2. 问题简化</h2><p>首先让我们<strong>简化一下问题</strong>。假设我现在只能用一款古董电脑，它只支持保存四位十进制整数的变量，也就是一个变量的保存范围为$[0,9999]$。如何计算两个四位整数相乘？</p><p>还记得乘法是怎么计算的吗？我们应该都学习过小学数学，通过将数字中的每一个字符看作计算单元，然后利用99乘法表就能够口算出结果了。</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/2021-04-29-08-44-58.png" srcset="/img/loading.gif" alt></p><p>或者可以每两个字符看成计算的基本单元，这样就需要计算两位数乘法。</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/2021-04-29-08-50-09.png" srcset="/img/loading.gif" alt></p><p>同样可以计算得到正确结果。假设每个方框是计算机的一个变量，后一种计算方式可以保证每个变量中保存的元素大小不超过计算机的保存能力（假设计算机保存能力为2位）。</p><p>回到题目本身。该运算的结果达到7位，超过了我们计算机限制的4位，因此可以使用两个变量保存该结果：<code>lo</code>保存结果的低四位，<code>hi</code>保存结果的高四位。</p><p>另外我们使用四个变量将两个乘数拆分成前后两个部分，<code>a</code>保存第一个操作数的高2位，<code>b</code>保存第一个操作数的低2位,<code>c</code>保存第二个操作数的高2位，<code>d</code>保存第二个操作数的低2位。</p><p>为什么要这么做？因为计算机的存储能力为4位，两个四位数字相乘，结果最多能达到八位，所以我们肯定不能容忍两个四位数字相乘；但是两个两位数字相乘，结果最多达到四位，是可以被当前的计算机所存储的。所以我们需要把四位数字拆分成前后两个部分。</p><p>抽象一下计算过程，以下不考虑进位。</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/2021-04-29-09-07-00.png" srcset="/img/loading.gif" alt></p><p>第一步，计算b与d的乘积，得到结果<code>bd</code>和进位k_1：</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/计算b与d的乘积.png" srcset="/img/loading.gif" alt></p><p>第二步，计算a与d的乘积，并且加上bd的进位k_1，得到结果ad和进位k_2，注意这个k_2最终会与ac求和：</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/计算a与d的乘积.png" srcset="/img/loading.gif" alt></p><p>第三步，计算b与c的乘积，得到结果bc和进位k_3：</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/计算b与c的乘积.png" srcset="/img/loading.gif" alt></p><p>第四步，计算a与c的乘积，并且加上bc的进位k_3，得到结果ac和进位k_4，注意这个k_4最终会成为高位hi的最大的部分，因此ac得到的k_4没必要和ac分离开：</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/计算a与c的乘积.png" srcset="/img/loading.gif" alt></p><p>第五步，低位结果计算，首先将ad和bc加起来，得到ad+bc以及可能存在的进位k_5；然后将ad+bc向左移位两格，再加上bd，就是低位结果lo。</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/低位结果计算.png" srcset="/img/loading.gif" alt></p><p>第六步，高位结果计算，将ac和进位k_5加起来，注意此时的ac包含了进位k_4，并没有分离出去。我们还需要加上计算ad得到的k_2，因此hi=ac+k_2+k_5。</p><p><img src="/2021/04/28/【竞赛打卡】两数相乘/高位结果计算.png" srcset="/img/loading.gif" alt></p><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h2><p>举一个具体点的例子：如何利用该电脑正确计算<code>1213*1214</code>？</p><script type="math/tex; mode=display">1213\times 1214=1,472,582</script><pre><code>a = 12b = 13c = 12d = 14</code></pre><ol><li>计算b与d的乘积，得到结果<code>bd</code>和进位k_1：<br>```<br>b <em> d = 13 </em> 14 = 182</li></ol><hr><p>k_1 = 1<br>bd = 82</p><pre><code>2. 计算a与d的乘积，并且加上bd的进位k_1，得到结果ad和进位k_2</code></pre><p>a <em> d + k_1 = 12 </em> 14 + 1 = 169<br>k_2 = 1<br>ad = 69</p><pre><code>3. 计算b与c的乘积，得到结果bc和进位k_3</code></pre><p>b <em> c = 13 </em> 12 = 156<br>k_3 = 1<br>bc = 56</p><pre><code>4. 计算a与c的乘积，并且加上bc的进位k_3，得到结果ac。此时不用分离进位，因此没有k_4。</code></pre><p>a <em> c + k_3 = 12 </em> 12 + 1 = 145<br>ac = 145</p><pre><code>5. 低位结果计算，首先将ad和bc加起来，得到ad+bc以及可能存在的进位k_5；然后将ad+bc向左移位两格，再加上bd，就是低位结果lo</code></pre><p>ad + bc = 125<br>k_5 = 1<br>adbc = 25<br>lo = adbc &lt;&lt; 2 + bd = 2500 + 82 = 2582</p><pre><code>6. 高位结果计算，将ac和进位k_5加起来，注意此时的ac包含了进位k_4，并没有分离出去。我们还需要加上计算ad得到的k_2，因此hi=ac+k_2+k_5</code></pre><p>hi = ac + k_2 + k_5 = 145 + 1 + 1 = 147</p><pre><code>最终结果的高位部分为147，低位部分为2582，与答案1472582相同。## 迁移到64位整数相乘以上我们讨论的都是四位整数相乘的问题，其实64位二进制数相乘也是一样的道理。首先我们将两个64位乘数OP1和OP2各自分成两半32位整数，也就是a/b/c/d，然后按照上述算法计算，即可得到结果的高64位和低64位。算法如下：```cppvoid mul_64_64_to_128(uint64_t op1, uint64_t op2, uint64_t *hi, uint64_t *lo) {    // 取abcd    uint64_t a, b, c, d;    b = (op1 &amp; 0xFFFFFFFF);    a = (op1 &gt;&gt; 32);    d = (op2 &amp; 0xFFFFFFFF);    c = (op2 &gt;&gt; 32);    // bd    uint64_t k_1 = b * d;    uint64_t bd = (k_1 &amp; 0xFFFFFFFF);    k_1 &gt;&gt;= 32;    // ad    uint64_t k_2 = a * d + k_1;    uint64_t ad = (k_2 &amp; 0xFFFFFFFF);    k_2 &gt;&gt;= 32;    // bc    uint64_t k_3 = b * c;    uint64_t bc = (k_3 &amp; 0xFFFFFFFF);    k_3 &gt;&gt;= 32;    // ac    uint64_t ac = a * c + k_3;    // lo    uint64_t k_5 = ad + bc;    uint64_t ad_bc = (k_5 &amp; 0xFFFFFFFF);    k_5 &gt;&gt;= 32;    *lo = (ad_bc &lt;&lt; 32) + bd;    // hi    *hi = ac + k_2 + k_5;}</code></pre><p>验证一下结果：</p><pre><code class="lang-cpp">int main() {    uint64_t op1 = 1e12;    uint64_t op2 = 1e12;    uint64_t hi = 0ULL, lo = 0ULL;    mul_64_64_to_128(op1, op2, &amp;hi, &amp;lo);    cout &lt;&lt; hi &lt;&lt; &quot;\n&quot; &lt;&lt; lo &lt;&lt; endl;    return 0;}&gt;&gt;&gt;542102003764205206896640Process finished with exit code 0</code></pre><p>乍一看结果，<code>1e12*1e12</code>结果怎么不是<code>1e24</code>呢？其实这是由于结果是十进制导致不直观，实际上我们的结果是正确的。我们比较下二进制就可以了。</p><p>首先定义一个函数<code>ulld_to_b</code>，将<code>uint64_t</code>变量转换为64位的二进制字符串：</p><pre><code class="lang-cpp">string ulld_to_b(uint64_t i) {    return bitset&lt;64&gt;(i).to_string();}</code></pre><p>然后查询<code>1e24</code>的二进制表示为：</p><pre><code>00000000000000000000000000000000000000000000000011010011110000100001101111001110110011001110110110100001000000000000000000000000</code></pre><p>该数值是我在<a href="https://www.sojson.com/hexconvert.html" target="_blank" rel="noopener">这个网站</a>上查询的。</p><p>然后编写测试用例：</p><pre><code class="lang-cpp">TEST(TestCase, test1) {    uint64_t op1 = 1e12;    uint64_t op2 = 1e12;    uint64_t hi = 0ULL, lo = 0ULL;    mul_64_64_to_128(op1, op2, &amp;hi, &amp;lo);    string res = &quot;&quot;;    res = ulld_to_b(hi) + ulld_to_b(lo);    cout &lt;&lt; res &lt;&lt; endl;    string ground_truth = &quot;00000000000000000000000000000000000000000000000011010011110000100001101111001110110011001110110110100001000000000000000000000000&quot;;    EXPECT_STREQ(ground_truth.c_str(), res.c_str());}int main(int argc, char** argv) {    testing::InitGoogleTest(&amp;argc, argv);    return RUN_ALL_TESTS();}</code></pre><p>没问题，通过了。当然，仅通过一个测试用例不算证明程序的正确性，勤劳的你可以多用几个测试用例试试。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.codeproject.com/Tips/618570/UInt-Multiplication-Squaring" target="_blank" rel="noopener">https://www.codeproject.com/Tips/618570/UInt-Multiplication-Squaring</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个大整数相乘，如何在不损失精度的前提下计算得到正确的结果？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="algorithm" scheme="https://superlova.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="https://superlova.github.io/tags/leetcode/"/>
    
      <category term="searching" scheme="https://superlova.github.io/tags/searching/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Docker综合实践</title>
    <link href="https://superlova.github.io/2021/04/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5/"/>
    <id>https://superlova.github.io/2021/04/24/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-04-24T14:16:40.000Z</published>
    <updated>2021-04-24T16:30:32.167Z</updated>
    
    <content type="html"><![CDATA[<p>Datawhale Docker学习笔记第六篇<br><a id="more"></a></p><p>在没有学习docker之前，部署项目都是直接启动文件，比如java项目就是java –jar xxxx.jar的方式，python项目就是python xxxx.py。如果采用docker的方式去部署这些项目，一般有两种方式，以jar包项目为例</p><h1 id="方式一、挂载部署"><a href="#方式一、挂载部署" class="headerlink" title="方式一、挂载部署"></a>方式一、挂载部署</h1><p>这种方式类似于常规部署，通过数据卷的方式将宿主机的jar包挂载到容器中，然后执行jar包的jdk选择容器中的而非采用本地的。</p><ol><li>将jar包上传到服务器的指定目录，比如/root/docker/jar。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yobtp2tj30o007njt5.jpg" srcset="/img/loading.gif" alt></p><ol><li>通过docker pull openjdk:8命令获取镜像</li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yord00xj30o006bju3.jpg" srcset="/img/loading.gif" alt></p><ol><li>编写docker-compose.yml文件</li></ol><pre><code class="lang-yaml">version:&#39;3.0&#39;services:  java:    image: docker.io/openjdk    restart:always    container_name: myopenjdk    ports:      - 8080:8001    volumes:      - /root/docker/jar/xxxx.jar:/root:z      - /etc/localtime:/etc/localtime    environment:      - TZ=&quot;Asia/Shanghai&quot;    entrypoint: java -jar /root/xxxx.jar    mynetwork:      ipv4_address: 192.168.1.13networks:  mynetwork:   ipam:     config:      - subnet: 192.168.1.0/24</code></pre><p>参数解释：</p><ul><li><p>build 指定dockerfile所在文件夹的路径 context指定dockerfile文件所在路径 dockerfile指定文件的具体名称</p></li><li><p>container_name 指定容器名称</p></li><li><p>volumes 挂载路径  z是用来设置selinux，或者直接在linux通过命令临时关闭或者永久关闭</p></li><li><p>ports 暴露端口信息</p></li><li><p>networks是用来给容器设置固定的ip</p></li></ul><ol><li>执行命令docker-compose up –d启动jar包, 可以通过docker ps查看容器是否在运行，需要注意的是默认查看所有运行中的容器，如果想查看所有容器，需要添加参数-a</li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yp7mo2wj30o0057aay.jpg" srcset="/img/loading.gif" alt></p><ol><li><p>注意如果容器启动失败或者状态异常，可以通过docker logs查看日志</p></li><li><p>通过docker inspect myopenjdk查看容器详细信息，可以看到容器ip已经设置成功</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9ypl8wgdj30o009wabq.jpg" srcset="/img/loading.gif" alt></p><ol><li>然后在虚拟机中打开浏览器输入jar包项目的访问地址，就可以看到运行的项目，需要注意访问端口是映射过的端口而非项目实际端口</li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yq1vynoj30o00dytaj.jpg" srcset="/img/loading.gif" alt></p><h2 id="方式二、构建镜像部署"><a href="#方式二、构建镜像部署" class="headerlink" title="方式二、构建镜像部署"></a>方式二、构建镜像部署</h2><ol><li><p>将jar包上传到服务器的指定目录，比如/root/docker/jar。</p></li><li><p>在该目录下创建Dockerfile文件，通过vim等编辑工具在Dockerfile中编辑以下内容</p></li></ol><pre><code class="lang-dockerfile">FROM java:8MAINTAINER YHFLABEL description=”learn docker”ADD xxx.jarEXPOSE 8001ENTRYPOINT [“java”,”-jar”,”xxxx.jar”]</code></pre><p>参数解释：</p><ul><li><p>FROM java:8 指定所创建镜像的基础镜像</p></li><li><p>MAINTAINER yhf 指定作者为yhf</p></li><li><p>LABEL 为生成的镜像添加元数据标签信息</p></li><li><p>ADD xxxx.jar 添加内容到镜像</p></li><li><p>EXPOSE 8080 声明镜像内服务监听的端口</p></li><li><p>ENTRYPOINT 指定镜像的默认入口命令，支持两种格式ENTRYPOINT[“java”,”-jar”,”xxxx.jar”]；ENTRYPOINT java –jar xxxx.jar。注意每个dokcerfile中只能有一个ENTRYPOINT，如果指定多个只有最后一个生效。</p></li></ul><ol><li><p>Dockerfile构建完成以后可以通过命令docker build构建镜像，然后再运行容器，这里咱们用docker-compose命令直接编排构建镜像和运行容器。</p></li><li><p>编写docker-compose.yml文件</p><p>```yaml<br>version: ‘3’</p></li></ol><p>services:</p><p>  java_2:<br>    restart: always<br>    image: yhfopenjdk:latest<br>    container_name: myopenjdk<br>    ports:</p><pre><code>  - 8080:8001volumes:  - /etc/localtime:/etc/localtimeenvironment:  - TZ=&quot;Asia/Shanghai&quot;entrypoint: java -jar /root/datawhale-admin-1.0.0.jarnetworks:  mynetwork:     ipv4_address: 192.168.1.13</code></pre><p>networks:<br>  mynetwork:<br>   ipam:<br>     config:</p><pre><code>  - subnet: 192.168.1.0/24</code></pre><p> ```</p><p>参数解释同方式一：</p><ol><li>执行docker-compose up –d直接启动基于文件构建的自定义镜像，如果镜像不存在会自动构建，如果已存在那么直接启动。如果想重新构建镜像，则执行docker-compose build。如果想在执行compose文件的时候重构，则执行docker-compose up –d –build。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yqi1lv0j30o007ign6.jpg" srcset="/img/loading.gif" alt></p><p>此使通过dockerfile文件构建的镜像已经创建</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yqxa7t1j30o005qdi5.jpg" srcset="/img/loading.gif" alt></p><p>通过镜像运行的容器已经正常启动，可以通过docker ps查看容器是否在运行，需要注意的是默认查看所有运行中的容器，如果想查看所有容器，需要添加参数-a</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yra1jg1j30o0013q33.jpg" srcset="/img/loading.gif" alt></p><ol><li>在浏览器中输入访问路径可以看到项目已经正常运行</li></ol><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp9yrmnnzzj30o00d975v.jpg" srcset="/img/loading.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datawhale Docker学习笔记第六篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Docker" scheme="https://superlova.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Docker Compose</title>
    <link href="https://superlova.github.io/2021/04/21/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker-Compose/"/>
    <id>https://superlova.github.io/2021/04/21/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker-Compose/</id>
    <published>2021-04-21T15:50:20.000Z</published>
    <updated>2021-04-21T16:02:36.263Z</updated>
    
    <content type="html"><![CDATA[<p>Datawhale Docker学习笔记第五篇<br><a id="more"></a></p><h1 id="什么是docker-compose"><a href="#什么是docker-compose" class="headerlink" title="什么是docker compose"></a>什么是docker compose</h1><p>要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等，这些需要多个容器相互配合来完成。</p><p>Docker Compose 允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p>下面是一个 docker-compose.yml 示例：</p><p><img src="/2021/04/21/【学习笔记】Docker-Compose/2021-04-21-23-54-09.png" srcset="/img/loading.gif" alt></p><p>里面多了image、ports、networks等标签。</p><h1 id="如何使用docker-compose"><a href="#如何使用docker-compose" class="headerlink" title="如何使用docker compose"></a>如何使用docker compose</h1><p>在Compose 中有两个重要的概念：</p><p><strong>服务 (service)</strong>：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p><p><strong>项目 (project)</strong>：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p><p>Compose的默认管理对象是<strong>项目</strong>，也就是通过docker-compose.yml定义的一组服务集合，通过一些命令来对项目中的一组容器进行便捷地生命周期管理。</p><p>下面我们来看一个真实的场景，在该场景下我们是通过Python来写一个能够记录页面访问次数的 web 网站。</p><h2 id="web-应用示例"><a href="#web-应用示例" class="headerlink" title="web 应用示例"></a>web 应用示例</h2><p><strong>app.py</strong></p><pre><code class="lang-py">from flask import Flaskfrom redis import Redisimport osimport socketapp = Flask(__name__)redis = Redis(host=os.environ.get(&#39;REDIS_HOST&#39;, &#39;127.0.0.1&#39;), port=6379)@app.route(&#39;/&#39;)def hello():    redis.incr(&#39;hits&#39;)    return &#39;Hello Container World! I have been seen %s times and my hostname is %s.\n&#39; % (redis.get(&#39;hits&#39;),socket.gethostname())if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)</code></pre><p><strong>Dockerfile</strong></p><pre><code class="lang-docker">FROM python:2.7COPY . /appWORKDIR /appRUN pip install flask redisEXPOSE 5000CMD [ &quot;python&quot;, &quot;app.py&quot; ]</code></pre><p><strong>docker-compose.yml</strong></p><pre><code class="lang-yaml">version: &quot;3&quot;services:  redis:    image: redis  web:    build:      context: .      dockerfile: Dockerfile    ports:      - &quot;5000:5000&quot;    environment:      REDIS_HOST: redis</code></pre><p><strong>运行 compose 项目</strong></p><p><code>$ docker-compose up -d</code></p><p>此时访问本地 5000 端口<a href="http://localhost:5000，每次刷新页面，计数就会加" target="_blank" rel="noopener">http://localhost:5000，每次刷新页面，计数就会加</a> 1。</p><h1 id="docker-compose基本使用"><a href="#docker-compose基本使用" class="headerlink" title="docker compose基本使用"></a>docker compose基本使用</h1><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>在创建好docker-compose.yml文件后，可以通过下面这个命令将文件中定义的容器都启动起来，在docker compose中我们更习惯于将每一个容器叫做service。</p><pre><code>docker-compose up</code></pre><p>命令后会自动接一个默认值-f docker-compose.yml，也就是默认是使用docker-compose.yml文件的。我们也可以给文件起名为docke-test.yml，这样在使用时指定文件名，但是为了符合规范，还是统一为docker-compose.yml。</p><pre><code>docker-compose up -f docer-test.yml</code></pre><p>但是直接通过这种方式的话会直接将启动时的输出打印到终端，所以我们常会加上-d参数。</p><pre><code>docker-compose up -d</code></pre><h2 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h2><p>接下来可以查看一下我们创建的service状态</p><pre><code>docker-compose ps</code></pre><p>要是想要查看所有service的状态可以使用-a参数：</p><pre><code>docker-compose ps -a</code></pre><h2 id="停止或删除服务"><a href="#停止或删除服务" class="headerlink" title="停止或删除服务"></a>停止或删除服务</h2><p>如何停止已经运行的services呢，可以使用以下两个命令</p><pre><code>docker-compose stopdocker-compose down</code></pre><p>其中stop是直接停止services，而down则会停止并删除创建的service，volume和network。</p><h2 id="进入服务"><a href="#进入服务" class="headerlink" title="进入服务"></a>进入服务</h2><p>有些情况下我们还需要进入容器来执行一些命令，可以通过如下方式进入容器</p><pre><code>docker-compose exec mysql bash</code></pre><p>exec后面接的就是我们要进入具体的service的名字，名字后面就是我们要执行的命令。</p><h2 id="查看服务输出日志"><a href="#查看服务输出日志" class="headerlink" title="查看服务输出日志"></a>查看服务输出日志</h2><p>有些情况下一些服务可能无法正常启动，这时可以使用命令查看日志并定位发生错误的原因</p><pre><code>docker-compose logs</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datawhale Docker学习笔记第五篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Docker" scheme="https://superlova.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>央行工作论文读后感</title>
    <link href="https://superlova.github.io/2021/04/21/%E5%A4%AE%E8%A1%8C%E5%B7%A5%E4%BD%9C%E8%AE%BA%E6%96%87%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://superlova.github.io/2021/04/21/%E5%A4%AE%E8%A1%8C%E5%B7%A5%E4%BD%9C%E8%AE%BA%E6%96%87%E8%AF%BB%E5%90%8E%E6%84%9F/</id>
    <published>2021-04-21T03:35:45.000Z</published>
    <updated>2021-04-24T09:59:18.905Z</updated>
    
    <content type="html"><![CDATA[<p>央行（中国人民银行）在2021年3月26日发表了一篇工作论文《关于我国人口转型的认识和应对之策》。论文一经发表便引起了全网的大讨论，新浪微博上的相关点击量达到3.2亿次。然而网络上的消息难免囿于其碎片话叙事风格，使人产生偏见。因此笔者抱着批判性学习的心态，拜读了该篇论文，并试图梳理主要内容，最后就相关观点提出自己的评论。<br><a id="more"></a></p><p>声明：本文并非学术文章，而是代表个人见解的社会评论；针对的也仅限于该篇文章，而不能涵盖文章所涉及的所有相关议题。本文写作目的仅出于学习和交流。本文作者并非研究人口与社会问题的专业人士，因此观点未免存在疏漏和幼稚之处，望读者海涵。</p><p>这篇工作论文的四名作者均是中国人民银行下属研究机构的经济学博士。作者还向当局提出放开计划生育、控制房价、重视储蓄和投资等建议。</p><p>所有的中国人民银行工作论文可在如下网站查看：<br><a href="http://www.pbc.gov.cn/yanjiuju/124427/133100/index.html" target="_blank" rel="noopener">http://www.pbc.gov.cn/yanjiuju/124427/133100/index.html</a></p><h1 id="论文原文内容摘录"><a href="#论文原文内容摘录" class="headerlink" title="论文原文内容摘录"></a>论文原文内容摘录</h1><p>以下将《关于我国人口转型的认识和应对之策》简称为“论文”。灰色引用部分和图表为原文内容，其余部分为本人评注。</p><h2 id="一、人口转型的规律"><a href="#一、人口转型的规律" class="headerlink" title="一、人口转型的规律"></a>一、人口转型的规律</h2><p>该部分讨论了经济社会发展和出生率与死亡率的关系问题。</p><blockquote><p>经济社会的发展将导致出生率和死亡率下降，但是死亡率会先于出生率下降，因此论文将人口增长状态分为四个阶段：低增长（I）、加速增长（II）、增长减缓（III）和恢复低增长（IV）。</p></blockquote><p><img src="/2021/04/21/央行工作论文读后感/2021-04-21-12-02-48.png" srcset="/img/loading.gif" alt></p><blockquote><p>发达经济体已经位于IV阶段，而大多数发展中经济体位于II或III阶段。</p></blockquote><p>什么是人口红利？人口红利是指生育率下降带来的劳动人口占比提升的现象。在人口红利时期，因为抚养子女和老人的压力变小，更多的人口能够从事经济发展有关的工作，因此这个地区相较于其他地区增长快。具体表现为居民储蓄率高、投资高等。</p><p>人口红利是一个地区发展的机会，但是能否利用这个机会，则有赖于社会和政治条件所创造的生产性就业和投资环境。</p><p>劳动适龄人口占多数的时期是短暂的（约50年），这一部分劳动人口终究会老去并成为负担，届时新一代人将成为社会发展的主力。这种人口红利之后的现象称之为人口转型。</p><p>什么是中等收入陷阱？经济水平长期处于中等收入水平的国家，经济社会发展长期停滞在该水平，受限于各种因素而无法跻身富裕国家行列，看起来好像陷入了一个“陷阱”之中。与“中等收入陷阱”类似的概念还有“贫困陷阱”。</p><h2 id="二、国外应对人口转型的经验和教训"><a href="#二、国外应对人口转型的经验和教训" class="headerlink" title="二、国外应对人口转型的经验和教训"></a>二、国外应对人口转型的经验和教训</h2><p>发达经济体早在工业革命时期就已经积累了一定的人口转型方面的经验和教训。具体表现在：</p><blockquote><p>教训：</p><ul><li>没料到会出现人口转型；</li><li>低估了人口对经济增长的作用；</li><li>低估了老龄化和少子化的危害。</li></ul></blockquote><p>前两点不言自明。而对于第三点，论文认为体现在：</p><blockquote><p>1）发达国家其一高估了教育和科技的作用；2）高估了鼓励生育的效果；3）高估了养老保障政策和养老产业的作用。</p><p>经验：</p><ul><li>资本扩张</li><li>移民</li></ul></blockquote><p>论文提到了这两点是十分行之有效的做法。但这就意味着要求国家发展到国际产业链的顶端，要“当大哥”才能获得这份利益。</p><h2 id="三、我们该如何应对人口转型？"><a href="#三、我们该如何应对人口转型？" class="headerlink" title="三、我们该如何应对人口转型？"></a>三、我们该如何应对人口转型？</h2><h3 id="3-1-目前问题很严峻"><a href="#3-1-目前问题很严峻" class="headerlink" title="3.1 目前问题很严峻"></a>3.1 目前问题很严峻</h3><p>论文指出，一方面我们同样面临人口红利即将结束的人口转型问题，</p><p><img src="/2021/04/21/央行工作论文读后感/2021-04-22-08-42-49.png" srcset="/img/loading.gif" alt></p><p>另一方面我们的问题比发达国家更为严重，我们“未富先老”；而且由于计划生育政策，我们的生育率下降得更快。在可以预见的将来，经济发展停滞，甚至是物价疲软、资产价格通缩、高负债等现象都可能出现。</p><p>选取美国和印度两个典型的国家进行比较，美国由于技术移民和资本扩张，人口结构问题并不是很突出。而印度正处于人口红利初期，具体可看下图：</p><p><img src="/2021/04/21/央行工作论文读后感/2019年中印美人口结构比较图.png" srcset="/img/loading.gif" alt></p><p>预计2050年，中印美三国的人口结构如下图所示：</p><p><img src="/2021/04/21/央行工作论文读后感/2050年预计中印美人口结构比较图.png" srcset="/img/loading.gif" alt></p><blockquote><p>如果说过去四十年我国缩小与美国的差距，靠的是廉价的劳动力和巨大的人口红利，那未来三十年要靠什么？这值得我们深思。</p></blockquote><h3 id="3-2-应对方案"><a href="#3-2-应对方案" class="headerlink" title="3.2 应对方案"></a>3.2 应对方案</h3><blockquote><p>用调控经济的思路去应对人口转型，多半事与愿违。所以一定要有提前量，并且搞得多多的，这样才不至于积重难返；一定要坚持，这样才有成效。</p><h4 id="3-2-1-全面放开生育。"><a href="#3-2-1-全面放开生育。" class="headerlink" title="3.2.1 全面放开生育。"></a>3.2.1 全面放开生育。</h4></blockquote><p>这应当是解决人口结构问题的大前提。</p><blockquote><h4 id="3-2-2-重视储蓄。"><a href="#3-2-2-重视储蓄。" class="headerlink" title="3.2.2 重视储蓄。"></a>3.2.2 重视储蓄。</h4></blockquote><p>老龄化会导致储蓄率下降。未雨绸缪不仅适用于个人，而且对于国家而言同样重要。从其仅次于第一点就能看出，储蓄率对解决人口结构问题至关重要。事实上储蓄率是国家和政府主导投资的核心，是经济发展的直接动力源之一。</p><blockquote><h4 id="3-2-3-重视投资。"><a href="#3-2-3-重视投资。" class="headerlink" title="3.2.3 重视投资。"></a>3.2.3 重视投资。</h4></blockquote><p>重视对我国中西部的投资、对亚非拉地区的投资，以及对科技的投资。</p><blockquote><h4 id="3-2-4-推进养老制度从即时支付型向储蓄型转移。"><a href="#3-2-4-推进养老制度从即时支付型向储蓄型转移。" class="headerlink" title="3.2.4 推进养老制度从即时支付型向储蓄型转移。"></a>3.2.4 推进养老制度从即时支付型向储蓄型转移。</h4></blockquote><p>我国的养老保险制度由三大支柱组成。第一支柱是基本养老保险，即人们常说的养老金；第二支柱即企业年金和职业年金；第三支柱包括个人储蓄性养老保险和商业养老保险。第三支柱以个人主导，工作时有一部分钱税前缴纳，退休取的时候再征税。</p><blockquote><p>削弱第一支柱的养老金，增强个人储蓄保险和商保的占比。这两者最大的区别，就是前者是政府兜底，而后者是市场化产品，政府不会补贴。</p></blockquote><p><a href="https://www.163.com/dy/article/G55MIAN2053907LI.html" target="_blank" rel="noopener">个人储蓄养老保险制度</a>参考这个网站。</p><p>不仅如此，论文还提到应该早点降低养老金、延长退休年龄，越早改革越好。用通俗的话来说，就是“别指望政府给你养老”。</p><blockquote><p>我国延迟退休可早做的一个原因在于，<strong>我国有社会主义的优越性，集体主义精神更强有利于避免发达国家延迟退休中的社会动荡；老一辈的人更能忍让、更能吃苦。</strong></p></blockquote><p>这一点经不起推敲，而且越读越让人感觉味道不对。</p><p>很喜欢王小波的一句话：“声称‘东方和西方的思考方式不一样’的人，其目的都是在掩饰一些自己也觉得不体面的事情。都是同一个物种，怎么会思想方式不同呢？”</p><p>而且，总不能因为班里同学好欺负，就挑软柿子捏，还说这是“软柿子的思想境界高”吧。</p><p>制定政策如果真的是为人民服务的，就应该接收人民群众的监督、承受一部分人的意见，并耐心回复和解答，这才是人民民主专政。</p><p>综上，笔者认为这一点不如不说。</p><blockquote><h4 id="3-2-5-促进教育和科技进步。"><a href="#3-2-5-促进教育和科技进步。" class="headerlink" title="3.2.5 促进教育和科技进步。"></a>3.2.5 促进教育和科技进步。</h4><p>给创新以兜底的社保；把握创新与监管的平衡；控房价；重视母亲和少儿的教育；重视基础教育；重视理工科教育，<strong>东南亚国家掉入中等收入陷阱原因之一是文科生太多</strong>；</p></blockquote><p><img src="/2021/04/21/央行工作论文读后感/控房价原文.png" srcset="/img/loading.gif" alt></p><p>笔者非常赞成关于控房价相关的论述。不仅如此，笔者认为控制房价还有助于提升居民储蓄率，进一步提升经济发展水平。</p><p>文科与理科的大讨论，不是一两句话能说明白的。简单讲，在没有明确“文科”和“理科”的定义之前，擅自对文理进行评价，是不妥当的。</p><p>当然，单纯以毕业生就业情况来看，以自动化、电子、机械、计算机等专业为首的理工科专业的确要比以语言、传媒、艺术等专业要方便就业。</p><p>但是就社会贡献来看，文科尤其是社会科学对社会的贡献要不亚于理工科学。毕竟我们国家的国策就是在马克思主义的指导下建立的。因此在概念模糊的时候不宜“捧一踩一”。</p><blockquote><p>老话讲，<strong>爹戳戳一个，娘戳戳一窝</strong>，所以教育好母亲比教育其他人事半功倍。事实上，教育母亲不是一句空话，可以从很多具体的小工作做起。比如，有发达国家就给每个育龄妇女分发孕前、孕中、孕后、育儿知识的小册子（政府组织专家编写，简单易懂，免费提供），而不是让大家去市场上买厚厚的、良莠不齐的、五花八门的生育指南。这样花钱不多，又成效显著。</p></blockquote><p>出自俗语“兵熊熊一个,将熊熊一窝”。</p><p>重视对母亲的教育，其实还是囿于传统文化的固有成见，即女性应该承担更多哺育孩子的任务。</p><p>如若从制度角度平衡两性之间的家庭职责，并令政府承担一部分新生儿抚养职能，比如给男性以产假、设立新生儿的政府统一抚养等，比单纯教育母亲要人性化得多。</p><blockquote><p>教育和科技进步周期长、见效慢、不可控，因此我国当前还是要以人、财、物的储蓄为本，教育和科技为辅。</p><p>不一定要建那么多学校、养那么多老师，可以用互联网技术让优质教育资源共享。</p></blockquote><p>这一点确实值得提倡。因为中国东西部教育资源分配不均现象，可以被互联网技术轻易解决。给贫困山区孩子配备一块显示器，然后去北京四中网校下载相应视频，孩子就能享受一流名师的教育教学了。</p><p>然而教育资源可不仅仅是课堂资源，生理指导、心理干预、学习习惯的形成等都需要老师手把手地进行指导。</p><p>今后老师的职能也许会从单纯的课堂教学，逐渐转化为学习、生活等方面的导师，引导学生们的发展。</p><p>这里减少老师和学校数目的倡议，应当是为了应对今后一段时间内新生儿数目减少所导致的需求降低。互联网技术的发展与老师数目的需求之间并无直接关系。</p><h1 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h1><h2 id="1-文笔"><a href="#1-文笔" class="headerlink" title="1. 文笔"></a>1. 文笔</h2><p>从行文上来看，本片工作论文与其说是一篇论文，不如说是一篇由央行背书的社会评论。从其观点的严谨程度到行文的文笔上都不够“学术”，更加口语化。</p><p>例如在第三章第二小节中的一段关于人口与经济的关系的论述如下所示：</p><ul><li>人口与经济的关系<strong>似乎有点像</strong>物价。过快增长不好，萎缩更糟糕，<strong>也许就像</strong>温和的通胀一样，适度、可持续的人口增长才有利于经济社会发展。</li></ul><p>再比如论文第14页的脚注中，关于日本“失去的二十年”的相关注解：</p><ul><li><strong>有人说</strong>，日本失去的二十年的主要原因是日本泡沫经济，而非人口老龄化。……（即便是上世纪三十年代的大萧条，持续时间即使算满，<strong>也就</strong>十年）。<strong>还有人说</strong>，……。 </li></ul><p>并且“有人说”之后也没有跟随参考文献，不由得让人怀疑该“人”的存在性。如此种种不一而足。</p><h2 id="2-储蓄率如何提升？"><a href="#2-储蓄率如何提升？" class="headerlink" title="2. 储蓄率如何提升？"></a>2. 储蓄率如何提升？</h2><p>本节参考自<a href="https://zhuanlan.zhihu.com/p/95800733" target="_blank" rel="noopener">《居民储蓄率与经济的关系》</a>一文。</p><p>论文中提到要“高度警惕和防止储蓄率过快下降的趋势”，并列举了一组数字：我国国民储蓄率从 2010 年的 47.8%，下降到 2018 年的 44.4%，8 年下降了 3.4 个百分点，其中居民储蓄率降幅更大，下降 7.3 个百分点。</p><p>储蓄率下降过快，会使得人口红利期积累下来的财富得不到保存。</p><p>虽然论文在解决方案的第二点就提到了“提升储蓄率”作为解决老龄化问题的方案，但是既没有讨论储蓄率下降的原因，也没有讨论储蓄率如何提升。</p><p>本节将讨论三个问题：</p><ol><li>储蓄率是什么？对经济发展重要吗？</li><li>储蓄率的影响因素有哪些？</li><li>既然储蓄率对国家如此重要，如何提升储蓄率？</li></ol><h3 id="2-1-居民储蓄率和经济之间的关系"><a href="#2-1-居民储蓄率和经济之间的关系" class="headerlink" title="2.1 居民储蓄率和经济之间的关系"></a>2.1 居民储蓄率和经济之间的关系</h3><p>首先需要明确，经济增长的三驾马车是消费、净出口和投资，其中投资依赖于本国储蓄率和外债。</p><p>储蓄率是指用于最终消费后的余额占所有可支配收入的比率。我国的国民储蓄中，居民储蓄是主要部分。</p><p>改革开放以来，中国经济的发展一直依赖于政府主导的大规模投资和大量出口。投资的钱怎么来？银行，银行的钱来自哪里？居民的高储蓄率。</p><p>说白了，你在银行里的存款越多，对政府的投资贡献越大。说不定高铁的一块铁轨、一个地铁站就用了你的一部分存款。</p><p>因此中国的投资大部分依赖于居民储蓄率，储蓄率的下降对经济发展有较大负面影响。</p><h3 id="2-2-老龄化和居民储蓄率之间的关系"><a href="#2-2-老龄化和居民储蓄率之间的关系" class="headerlink" title="2.2 老龄化和居民储蓄率之间的关系"></a>2.2 老龄化和居民储蓄率之间的关系</h3><p>储蓄率和人口结构是有关系的，只不过关系不那么明显。</p><p>人的一生中，消费和储蓄模式会发生变化。</p><p>一个人从事劳动的年份，他们的收入大于消费，由此产生的盈余用于抚养子女以及存入银行。</p><p>而老年人一般将其收入的大部分花在住房和社会服务方面，另外保健和长期护理方面的需求可能会上升，娱乐、交通运输方面的需求可能会下降。</p><p>因此，理论上，当社会中有收入的青壮年逐步减少、没有收入的老人越来越多时，居民的储蓄率就会下降。</p><p>不过储蓄率往往受其他因素影响，因此老龄化与居民储蓄率之间的关系并不是绝对相关的。</p><h3 id="2-3-影响居民储蓄率的其他原因"><a href="#2-3-影响居民储蓄率的其他原因" class="headerlink" title="2.3 影响居民储蓄率的其他原因"></a>2.3 影响居民储蓄率的其他原因</h3><p>虽然老龄化会对居民储蓄率产生一定程度的影响，但还有很多其他因素影响人们的储蓄行为，比如：</p><ul><li>收入水平、资产价值和分配情况</li><li>对未来发展的估计</li><li>税率</li><li>现行养恤金制度</li><li>老年医疗和临终关怀等</li></ul><p>其中居民存款的增长与否与居民收入有很大关系。当经济向好时，居民收入有大幅增长，存款就增大；当经济下行时，居民收入增长较缓，存款增长就放缓。</p><p>既然老龄化和居民收入等原因都会影响居民储蓄率，那么究竟什么是中国居民储蓄率快速下降的主要原因？</p><h3 id="2-4-储蓄率降低的主要原因"><a href="#2-4-储蓄率降低的主要原因" class="headerlink" title="2.4 储蓄率降低的主要原因"></a>2.4 储蓄率降低的主要原因</h3><blockquote><p>“房价太高，再怎么放开生育我都不会生的。”</p></blockquote><p>由于近年教育、医疗、房产等的价格的上升，居民在以上几项当中的消费额增加，致使居民储蓄率下降。特别是房地产在家庭资产配置当中占有非常大的比例，已经大大超过了存款。</p><p>据央行一季度金融统计数据新闻发布会消息，2020年居民杠杆率为 45.7% ，比2019年上升了 7.1% 。</p><p><a href="http://finance.sina.com.cn/zl/china/2021-04-18/zl-ikmxzfmk7496559.shtml" target="_blank" rel="noopener">http://finance.sina.com.cn/zl/china/2021-04-18/zl-ikmxzfmk7496559.shtml</a></p><p>居民部门杠杆率增幅较大主要是受房地产市场影响。数据显示，在全部居民债务中，占最大比例的即是居民中长期消费贷款（主要是住房按揭贷款），占到了全部居民贷款的65%。</p><p><img src="/2021/04/21/央行工作论文读后感/2021-04-23-13-16-09.png" srcset="/img/loading.gif" alt></p><p>让我们再说得明白些。居民买房的首付使用了六个钱包，这六个钱包中或许还包含私人借债，因此实际居民借债率可能远高于这个数字。</p><p>中国居民已经逐渐由资金供给方变为资金的需求方。高房价掏空了年轻人们的钱包，房贷车贷负债累累，谈何储蓄？</p><h3 id="2-5-如何令居民储蓄率上升？"><a href="#2-5-如何令居民储蓄率上升？" class="headerlink" title="2.5 如何令居民储蓄率上升？"></a>2.5 如何令居民储蓄率上升？</h3><p>2.5 和 2.6 参考自<a href="https://www.thepaper.cn/newsDetail_forward_11420531" target="_blank" rel="noopener">《从养老负担和储蓄率之间的关系，深入解析中国“老龄化》</a>一文。</p><p>目前我国的储蓄中，有较大的份额是来自政府和企业，这是国民经济分配失衡所造成的。调整分配，使居民的收入份额上升，对缓解养老压力十分关键。同时，调整政府支出结构，增加公共物品供给，使居民用于这类产品的支出降下来，增加他们的净财富，有助于他们提高养老保障能力。</p><p>在高储蓄率下，之所以仍然面临巨大的养老压力，与过高的收入分配差距有关，低收入人群的养老风险较高的，他们需要为养老而储蓄，但是恰恰是他们的收入水平过低，无力储蓄。所以对养老问题并不能从问题本身来谈论。应对措施也应该更具有综合性和整体性，调节收入分配尤其重要。</p><h3 id="2-6-如何提升养老金缴费比率？"><a href="#2-6-如何提升养老金缴费比率？" class="headerlink" title="2.6 如何提升养老金缴费比率？"></a>2.6 如何提升养老金缴费比率？</h3><p>目前中国的养老金缴费率比较低。中国的非正规就业规模较大，这部分就业者主要是中低收入人群，他们之所以不愿意参保，原因在于缴纳养老金并不符合他们的利益最大化目标。</p><p>有两个比较明显的直接原因。</p><p>一是中国近年来的通货膨胀率较高，这就意味着未来的领取的养老金现值也较少；</p><p>二是中国的城市住房价格快速上涨，住房投资的回报率较高，这也促使劳动者更愿意领取较高的工资而不太看重养老金，因为当前领取工资收入，可以尽早积累起足够的资金用于买房或者其他投资，而养老金只能到退休以后才能领取。</p><p>高通胀和资产价格膨胀使人们增强了流动性偏好，而缴纳养老金对个人来说意味着增加了流动性较低的资产，劳动者更愿意选择哪怕是略微高一些的工资，而不是一个较低的工资加上一份养老保险。</p><p>因而在这种情况下，强制缴纳养老保险的规定往往难以得到落实，企业和雇员会努力采取措施规避这种规定。即使政府出台严格的规定，强制企业缴纳养老保险，个人和企业也都有很强的动机来规避。</p><p>当然，社会养老保障的参保率提高缓慢的原因是多方面的，例如缴费在地区间不可携带，高通胀和资产回报较高可能是一个重要原因。因此，治理通胀和维持房价稳定有助于养老体制的完善。</p><h2 id="3-文理之争"><a href="#3-文理之争" class="headerlink" title="3. 文理之争"></a>3. 文理之争</h2><p>“文科生太多”的说法在网络上引发轩然大波。话题“#文科生太多会影响国家发展吗”在中国社交媒体微博上的阅读量超过3.2亿次，大部分网友对此持批评态度。</p><p><img src="/2021/04/21/央行工作论文读后感/文科生太多.png" srcset="/img/loading.gif" alt></p><p>众所周知，我国理科生与文科生素来不睦，前者蔑视后者没逻辑，后者鄙夷前者没文化。</p><p>不过在网上的论战中，理科生底气更足一些。毕竟社会上一直流传着“学好数理化、走遍天下都不怕”的说法。相对地，文科一直被认为“无用”。</p><p>2020年，一名来自湖南省的高考状元因在大学选择了考古专业，再度在社交媒体引发争论。有网友认为考古专业“没钱途”，规劝她换专业。</p><p>但是人们在讨论文科和理科的时候，是否能够确切说出什么是“文科”，什么是“理科”呢？</p><p>关于文科生和理科生的定义，建议看下<a href="https://matters.news/@xiemeng/%E4%BB%8E%E7%BF%BB%E8%AF%91%E7%A4%BE%E4%BC%9A%E5%AD%A6%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%96%87%E7%A7%91%E7%94%9F%E4%B8%8E%E7%90%86%E7%A7%91%E7%94%9F%E7%9A%84%E4%BA%92%E7%9B%B8%E9%84%99%E5%A4%B7-bafyreicrdy7y4fnmjktwnsxv6ljmkiq3ga4yqo5lvjzn3ng74fog32a6jm" target="_blank" rel="noopener">这篇文章的介绍</a>，相当全面。</p><p>透过现象看本质，现实情况是一些中国大学文科毕业生确实面临“就业难”和“薪资低”的困境。</p><p>加上2019年国务院发布的职业教育改革方案，能够看出国家其实是想解决一些行业人口过剩但高级技工人才短缺的问题。所以问题不在于文理之争，而在于人才分配不均。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>人口结构问题已成为中国未来发展所必须面对的问题。央行论文提出了一揽子解决方法，包括解除生育限制、提升储蓄率、稳房价和鼓励创新等；但也包含一些本人所不理解的观点，如储蓄率与人口结构的关系，关于“吃苦”的论述，以及“爹戳戳一个，娘戳戳一窝”的观点等。笔者就上述部分观点进行了深入调研和思辩。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>胡翠, 许召元. 人口老龄化对储蓄率影响的实证研究[J]. 经济学 (季刊), 2014, 13(4).</p><p>United Nations. Department of Economic and Social Affairs. World Economic and Social Survey 2007: Development in an ageing world[M]. UN, 2007.</p><p>一些参考文章链接已直接在原文列出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;央行（中国人民银行）在2021年3月26日发表了一篇工作论文《关于我国人口转型的认识和应对之策》。论文一经发表便引起了全网的大讨论，新浪微博上的相关点击量达到3.2亿次。然而网络上的消息难免囿于其碎片话叙事风格，使人产生偏见。因此笔者抱着批判性学习的心态，拜读了该篇论文，并试图梳理主要内容，最后就相关观点提出自己的评论。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="record" scheme="https://superlova.github.io/categories/record/"/>
    
    
      <category term="middle income trap" scheme="https://superlova.github.io/tags/middle-income-trap/"/>
    
      <category term="social sciences" scheme="https://superlova.github.io/tags/social-sciences/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Docker网络</title>
    <link href="https://superlova.github.io/2021/04/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E7%BD%91%E7%BB%9C/"/>
    <id>https://superlova.github.io/2021/04/18/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E7%BD%91%E7%BB%9C/</id>
    <published>2021-04-18T13:53:06.000Z</published>
    <updated>2021-04-18T15:57:36.755Z</updated>
    
    <content type="html"><![CDATA[<p>Datawhale Docker学习笔记第四篇<br><a id="more"></a></p><h1 id="Docker-基础网络介绍"><a href="#Docker-基础网络介绍" class="headerlink" title="Docker 基础网络介绍"></a>Docker 基础网络介绍</h1><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过-P或-p参数来指定端口映射。</p><p>当使用-P标记时，Docker会随机映射一个端口到内部容器开放的网络端口。 使用docker container ls可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><pre><code>$ docker run -d -P nginx:alpine$ docker container ls -lCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMESfae320d08268        nginx:alpine        &quot;/docker-entrypoint.…&quot;   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</code></pre><p>同样的，可以通过docker logs命令来查看访问记录。</p><pre><code>$ docker logs fa172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot; &quot;-&quot;</code></pre><p>-p则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>.</p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>下面先创建一个新的 Docker网络。</p><pre><code>$ docker network create -d bridge my-net</code></pre><p>-d参数指定Docker网络类型，有bridge overlay,其中overlay网络类型用于Swarm mode，在本小节中你可以忽略它。</p><p>运行一个容器并连接到新建的my-net网络</p><pre><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code></pre><p>打开新的终端，再运行一个容器并加入到 my-net网络</p><pre><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh</code></pre><p>再打开一个新的终端查看容器信息</p><pre><code>$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESb47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox28720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</code></pre><p>下面通过 ping来证明busybox1容器和busybox2容器建立了互联关系。 在busybox1容器输入以下命令</p><pre><code>/ # ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</code></pre><p>用ping来测试连接busybox2容器，它会解析成 172.19.0.3。 同理在busybox2容器执行ping busybox1，也会成功连接到。</p><pre><code>/ # ping busybox1PING busybox1 (172.19.0.2): 56 data bytes64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</code></pre><p>这样，busybox1 容器和 busybox2 容器建立了互联关系。</p><p>Docker Compose 如果你有多个容器之间需要互相连接，推荐使用DockerCompose。</p><h2 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是Docker利用虚拟文件来挂载容器的 3个相关配置文件。</p><p>在容器中使用 mount命令可以看到挂载信息：</p><pre><code>$ mount/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 .../dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...tmpfs on /etc/resolv.conf type tmpfs ...</code></pre><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有Docker容器的 DNS 配置通过 /etc/resolv.conf文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。</p><pre><code>{  &quot;dns&quot; : [    &quot;114.114.114.114&quot;,    &quot;8.8.8.8&quot;  ]}</code></pre><p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和8.8.8.8。使用以下命令来证明其已经生效。</p><pre><code>$ docker run -it --rm ubuntu:18.04  cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8</code></pre><p>如果用户想要手动指定容器的配置，可以在使用docker run命令启动容器时加入如下参数： -h HOSTNAME或者—hostname=HOSTNAME设定容器的主机名，它会被写到容器内的/etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在docker container ls中显示，也不会在其他的容器的/etc/hosts看到。</p><p>—dns=IP_ADDRESS添加 DNS 服务器到容器的/etc/resolv.conf中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p><p>—dns-search=DOMAIN设定容器的搜索域，当设定搜索域为.example.com时，在搜索一个名为host的主机时，DNS 不仅搜索 host，还会搜索host.example.com。</p><p><strong>注意：</strong>如果在容器启动时没有指定最后两个参数，Docker会默认用主机上的/etc/resolv.conf来配置容器。</p><h1 id="Docker的网络模式"><a href="#Docker的网络模式" class="headerlink" title="Docker的网络模式"></a>Docker的网络模式</h1><p>可以通过docker network ls查看网络，默认创建三种网络。</p><pre><code>[root@localhost ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE688d1970f72e        bridge              bridge              local885da101da7d        host                host                localf4f1b3cf1b7f        none                null                local</code></pre><p>常见网络的含义：</p><div class="table-container"><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Bridge</td><td>为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，默认为该模式。</td></tr><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</td></tr><tr><td>None</td><td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。</td></tr><tr><td>Container</td><td>新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</td></tr></tbody></table></div><h2 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h2><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上，附加在其上的任何网卡之间都能自动转发数据包。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从docker0子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过brctl show命令查看。</p><h2 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h2><p>host 网络模式需要在创建容器时通过参数 —net host 或者 —network host 指定；<br>采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换；<br>host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。</p><h2 id="None-模式"><a href="#None-模式" class="headerlink" title="None 模式"></a>None 模式</h2><p>none 网络模式是指禁用网络功能，只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。在创建容器时通过参数 —net none 或者 —network none 指定；<br>none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。可以说 none 模式为 Docke Container 做了极少的网络设定，但是俗话说得好“少即是多”，在没有网络配置的情况下，作为 Docker 开发者，才能在这基础做其他无限多可能的网络定制开发。这也恰巧体现了 Docker 设计理念的开放。</p><h2 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h2><p>Container 网络模式是 Docker 中一种较为特别的网络的模式。在创建容器时通过参数 —net container:已运行的容器名称|ID 或者 —network container:已运行的容器名称|ID 指定；<br>处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。</p><p>Container 网络模式即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datawhale Docker学习笔记第四篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Docker" scheme="https://superlova.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Docker数据管理、数据卷和挂载主机目录</title>
    <link href="https://superlova.github.io/2021/04/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%92%8C%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95/"/>
    <id>https://superlova.github.io/2021/04/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%92%8C%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95/</id>
    <published>2021-04-16T13:25:46.000Z</published>
    <updated>2021-04-16T16:28:09.965Z</updated>
    
    <content type="html"><![CDATA[<p>Datawhale Docker学习笔记第三篇<br><a id="more"></a></p><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><ul><li>创建数据卷<pre><code>docker volume create datawhale</code></pre>查看所有的数据卷<pre><code>docker volume ls</code></pre></li><li>启动一个挂载数据卷的容器</li></ul><p>在用 docker run 命令的时候，使用 —mount 标记来将数据卷挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p><ul><li>查看数据卷的具体信息</li></ul><p>在主机里使用以下命令可以查看 web 容器的信息</p><pre><code>docker inspect web</code></pre><ul><li><p>删除数据卷</p><pre><code>docker volume rm datawhale  #datawhale为卷名</code></pre><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>docker volume prune</code></pre><h1 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h1></li><li><p>挂载一个主机目录作为数据卷</p><pre><code>docker run -d -P \  --name web \  --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \  nginx:alpine</code></pre><p>使用 —mount 标记可以指定挂载一个本地主机的目录到容器中去。</p></li><li><p>查看数据卷的具体信息</p></li></ul><p>在主机里使用以下命令可以查看 web 容器的信息</p><pre><code>docker inspect web</code></pre><ul><li>挂载一个本地主机文件作为数据卷</li></ul><p>—mount 标记也可以从主机挂载单个文件到容器中</p><pre><code>docker run --rm -it \   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \   ubuntu:18.04 \   bash</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datawhale Docker学习笔记第三篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Docker" scheme="https://superlova.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】如何求出任意日期是星期几？</title>
    <link href="https://superlova.github.io/2021/04/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%A6%82%E4%BD%95%E6%B1%82%E5%87%BA%E4%BB%BB%E6%84%8F%E6%97%A5%E6%9C%9F%E6%98%AF%E6%98%9F%E6%9C%9F%E5%87%A0%EF%BC%9F/"/>
    <id>https://superlova.github.io/2021/04/16/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%A6%82%E4%BD%95%E6%B1%82%E5%87%BA%E4%BB%BB%E6%84%8F%E6%97%A5%E6%9C%9F%E6%98%AF%E6%98%9F%E6%9C%9F%E5%87%A0%EF%BC%9F/</id>
    <published>2021-04-16T11:59:38.000Z</published>
    <updated>2021-04-16T14:56:40.494Z</updated>
    
    <content type="html"><![CDATA[<p>已知某年月日，如何得到这一天是星期几？<br>已知两日期的年月日，如何得到这两日期之间相差多少天？<br>如此种种问题，均可以利用蔡勒公式解决。</p><a id="more"></a><h1 id="一、已知日期y年m月d日，如何求解该日期是周几？"><a href="#一、已知日期y年m月d日，如何求解该日期是周几？" class="headerlink" title="一、已知日期y年m月d日，如何求解该日期是周几？"></a>一、已知日期y年m月d日，如何求解该日期是周几？</h1><h2 id="1-问题转化"><a href="#1-问题转化" class="headerlink" title="1. 问题转化"></a>1. 问题转化</h2><p>该问题容易转换为计算1年1月1日与y年m月d日之间的差值。如何计算两个日期之间的差值？</p><p>不难想到，首先求解前y年的天数$w_1$，然后求解从y年1月1日到y年m月1日之间的天数$w_2$，最后求解m月1日到m月d日之间的天数（即为d天），将这三个值相加即可得到结果$w$。</p><p><img src="/2021/04/16/【学习笔记】如何求出任意日期是星期几？/计算方法.png" srcset="/img/loading.gif" alt></p><p>得到天数$w$之后，将值与7取余，$w\mod 7 == 1$ 就是星期一， $w\mod 7 == 2$ 就是星期二，$w\mod 7 == 0$ 就是星期天。</p><h2 id="2-判断闰年"><a href="#2-判断闰年" class="headerlink" title="2. 判断闰年"></a>2. 判断闰年</h2><p>这个问题的难点在于年和月的计算。一年有365天，闰年是366天（2月中多一天）。如何判断y是闰年还是平年？</p><p>按照我们一直以来学习的知识，闰年按照如下方法进行计算：</p><p>普通闰年：公历年份是4的倍数，且不是100的倍数的，为闰年（如2004年、2020年等就是闰年）。</p><p>世纪闰年：公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是闰年，2000年是闰年）。</p><p>则y年对应的天数 $w_1$ 可以这样计算：</p><script type="math/tex; mode=display">w_1 = 365\times y + \frac{y}{4} - \frac{y}{100} + \frac{y}{400}</script><h2 id="3-计算月份对应的天数"><a href="#3-计算月份对应的天数" class="headerlink" title="3. 计算月份对应的天数"></a>3. 计算月份对应的天数</h2><p>每个月的天数是不同的，并且根据当年是平年还是闰年，1月到m月之间的日期也有所不同，不能一概而论。难道我们需要使用各种情况分析，通过嵌套if语句，最后得到一个丑陋但能用的怪物吗？不必！下面两种情况都能在 O(1) 的空间和时间复杂度内计算得到 y年1月1日到y年m月1日之间的天数。</p><h3 id="3-1-平凡解法：储存12个月对应的天数表"><a href="#3-1-平凡解法：储存12个月对应的天数表" class="headerlink" title="3.1 平凡解法：储存12个月对应的天数表"></a>3.1 平凡解法：储存12个月对应的天数表</h3><p>最容易想到的当然是将平年的12个月对应的天数存在数组中，闰年的另外保存12个月的天数。每次计算，直接取对应下标的值即可。</p><pre><code class="lang-python">def compute_date_normal(y, m, d):    isleap = False    if (y % 4 == 0 and y % 100 != 0) or y % 400 == 0:        isleap = True    y = y - 1  # 计算经过了完整的多少年    yd = 365 * y + y // 4 - y // 100 + y // 400    month_arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]    leap_month_arr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]    if isleap:        md = sum(leap_month_arr[:m - 1])    else:        md = sum(month_arr[:m - 1])    # print(yd, md, d)    return yd + md + d</code></pre><h3 id="3-2-蔡勒公式：24个参数-—-gt-3个参数"><a href="#3-2-蔡勒公式：24个参数-—-gt-3个参数" class="headerlink" title="3.2 蔡勒公式：24个参数 —&gt; 3个参数"></a>3.2 蔡勒公式：24个参数 —&gt; 3个参数</h3><p>有没有更优雅、更酷的方法来改进该算法？有的！我们可以使用一个神奇的公式：蔡勒公式。</p><p>克里斯蒂安·蔡勒（Julius Christian Johannes Zeller，1822-1899）是一名德国数学家。蔡勒公式（Zeller’s congruence），是一种计算任何一天是一星期中哪一天的算法，由德国数学家克里斯提安·蔡勒发表。蔡勒公式的特点是不用判断闰年平年，不用判断大小月，直接在O(1)的复杂度下解决日期和星期的转换问题。很神奇是吧？</p><p>具体地，蔡勒公式计算的是从公元1年1月1日到某日期过了多少天。天数$w$的计算方法如下所示：</p><script type="math/tex; mode=display">w = 365\times y + \frac{y}{4} - \frac{y}{100} + \frac{y}{400} + \frac{153\times m-457}{5} + d - 306</script><p>其中y为某一年，m为该年中的某一月，d为该月中的某一天。</p><hr><p>好吧，你肯定会问 153、457和306这三个参数是从哪里来的了。</p><p>不要以为蔡勒公式中的前半部分还是$w_1$的解法，事实上蔡勒公式把y年全年都给算进去了！也就是说，蔡勒公式的前半部分$w_1$多计算了y年m月d日到y年12月31日这段日期。</p><p>接下来计算这段日期的长度。但是蔡勒公式不急着做这件事，而是计算了y年12月31日到y年3月1日之间经过了多少天。后半部分计算月份的分式我们将其命名为$w_2$：</p><script type="math/tex; mode=display">w_2=M_3+M_4+\cdots+M_12=31+30+\cdots+31=306</script><p>上式中$M_n$为n月的天数。</p><hr><p>为什么选择3月1日作为起始呢？因为3月到12月对于平年和闰年来说都是固定的，因此该数值也是固定的，为306天。</p><p>但是如果我们计算1月1日到12月31日的长度的话，就会因为2月的不稳定性而需要分类讨论了。</p><p>由此，只要我们计算的月份不是1月和2月，那么我们不必在乎这一年到底是闰年还是平年。</p><p>那么如果我计算的日期的确是1月或2月的某日怎么办呢？要想避免讨论平年闰年，无论如何都要避过计算2月！</p><p>蔡勒公式采取的方案是，不计算到y年12月31日，而是少计算一年(1.01.01)—(y-1.12.31)，再加上12个月。由此，原来的1月就变成了13月，原来的2月就变成了14月。</p><hr><p>下面将是蔡勒公式中最难以理解的部分，那就是计算从y年3月1日到4月（X月）1日之间经过了多少天这一部分。</p><p>我们首先看一个统计表，这个表列出了3月1日到各个月份的首日（X月1日）之间经过了多少天：</p><div class="table-container"><table><thead><tr><th style="text-align:center">月份</th><th style="text-align:center">该月天数</th><th style="text-align:center">该月首天与3/1的差值</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">31</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">30</td><td style="text-align:center">31</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">31</td><td style="text-align:center">61</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">30</td><td style="text-align:center">92</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">31</td><td style="text-align:center">122</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">31</td><td style="text-align:center">153</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">30</td><td style="text-align:center">184</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">31</td><td style="text-align:center">214</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">30</td><td style="text-align:center">245</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">31</td><td style="text-align:center">275</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">31</td><td style="text-align:center">306</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">X</td><td style="text-align:center">337</td></tr></tbody></table></div><p>我们想找到一个简单的映射关系，能把月份给换算成该月首天与3月1日之间的差值：$f(m)$。</p><p>细心观察我们可以发现，除了个位之外，该差值是一个等差数列，公差为30天。而个位的变化为1,1,2,2,3,4,4,5,5,6,7.</p><p>存不存在一个线性函数，能够拟合个位的变化呢？答案是有的，那就是：</p><script type="math/tex; mode=display">\lfloor\frac{m\times 3-7}{5}\rfloor</script><p>左右括号是向下取整。其实我现在也没能找到该式与该问题之间的逻辑关系，但是该式恰好能够拟合差值的个位数变化，因此我也就“拿来主义”了。</p><p>至此我们已经得到月份和差值之间的函数关系：</p><script type="math/tex; mode=display">w_3=30\times(m-3)+\lfloor(m\times3-7)/5\rfloor</script><script type="math/tex; mode=display">=⌊(153×m-457)/5⌋</script><p>在公式的最后，将日期d加上，我们就得到了最终的蔡勒公式。</p><p>下面是蔡勒公式的具体实现。可以看到，代码的确短了很多，而且参数也从24个变成了3个。</p><pre><code class="lang-python">def zellers(y, m, d):    if m &lt; 3:        y -= 1        m += 12    return 365*y + y//4 - y//100 + y//400 + (153*m-457)//5 + d – 306def test_zellers():    w = zellers(2021,1,7)    print((w%7+7)%7)</code></pre><h1 id="二、奇思妙想"><a href="#二、奇思妙想" class="headerlink" title="二、奇思妙想"></a>二、奇思妙想</h1><p>知其然，更要知其所以然。我写这篇文章的目的，其实是因为我碰到了一道笔试题，在解题过程中，我无意发现了一些有趣的解法，但是网上的文章又不能解答我的疑问，所以我就想通过自己的调研，解答自己的问题。如果这个问题的回答能帮到你，那就再好不过了。</p><h2 id="1-为什么闰年这样计算"><a href="#1-为什么闰年这样计算" class="headerlink" title="1. 为什么闰年这样计算"></a>1. 为什么闰年这样计算</h2><p>闰年是为了弥补因人为历法规定的年度天数365日和实际公转时间365.25日的差距而设立的。即是，每四年便会累积1日 ，所以四年便会有一次闰年。多出来的一天为2月29日。</p><p>其实闰年的计算方法一直是有争议的，因为一年的公转日纪年误差会随着年份的累计而不断扩大，最终必须以一天的的方式扩展开来。</p><p>“四年一闰，百年不闰，四百年再闰”，这就造成了在一些特殊年份，会出现八年一闰的现象。</p><p>闰年这个东西其实也是舶来品，因为中国传统纪年方式是按照农历纪年的，我们会在一年之中添加一个月，称之为闰月。</p><p>农历作为阴阳历的一种，每月的天数依照月亏而定，一年的时间以12个月为基准，平年比一回归年少约11天。为了合上地球围绕太阳运行周期即回归年，每隔2到3年，增加一个月，增加的这个月为闰月。闰月加到哪个月，以农历历法规则推断，主要依照与农历的二十四节气相符合来确定。在加有闰月的那一年有13个月，历年长度为383至385日，这一年也称为闰年。如2004年猴年的农历中，有两个二月，通常称为前二月和后二月（即闰月）。</p><p>而现在使用公元纪年，则是格里高利历所规定。</p><h2 id="2-公元纪年"><a href="#2-公元纪年" class="headerlink" title="2. 公元纪年"></a>2. 公元纪年</h2><p>公元是公历纪元的简称，是一个被当今国际社会最广泛地使用的纪年标准。其源自于西方国家使用的基督纪年，以当时认定的耶稣出生年为纪年的开始。第一年被称作基督元年（耶稣出生的那一年）。后来，由于西方文化的强势，西历纪元成为世界通用标准。</p><p>1911 年 10 月 10 日辛亥革命后，湖北军政府使用黄帝纪年。次年 （1912年），中华民国临时政府决定采用国际通用的公元历法做为国历，但纪元部分沿用中国独自的纪年传统，称民国纪年。</p><p>1949年9月27日，中国人民政治协商会议第一届全体会议决议，同年10月1日成立的中华人民共和国放弃使用民国纪年，改采用世界通用的公元纪年制度[5]，大陆地区改称“公元”，以昭明其是“国际共同”，避免“西方独用”的歧义。</p><h2 id="2-公元1年1月1日是星期几？"><a href="#2-公元1年1月1日是星期几？" class="headerlink" title="2. 公元1年1月1日是星期几？"></a>2. 公元1年1月1日是星期几？</h2><p>如果你以为你的程序特别厉害了，那我可要考考你了：公元1年1月1日是星期几？</p><p>按照上文分析，应该是周一。但是知乎上的回答指出，这样计算是不对的：</p><p><img src="/2021/04/16/【学习笔记】如何求出任意日期是星期几？/知乎回答.png" srcset="/img/loading.gif" alt></p><p>教皇格里戈八世在1582年2月24日颁布法令，永远抹去了1582年10月5日到1582年10月14日。历史上从来不曾有过这10天。1582年10月4日是星期四，它的第二天是1582年10月15日星期五。因此考虑到这10天的影响再去推算，公元元年1月1日就是星期六了。</p><p>这方面还是华为的手机日历比较厉害：</p><p><img src="/2021/04/16/【学习笔记】如何求出任意日期是星期几？/华为.png" srcset="/img/loading.gif" alt></p><p><img src="/2021/04/16/【学习笔记】如何求出任意日期是星期几？/华为2.png" srcset="/img/loading.gif" alt></p><p>可以清楚地看到，从1582年10月5日到1582年10月14日的十天被永远抹去了。</p><p>华为，牛！</p><h2 id="变化问题"><a href="#变化问题" class="headerlink" title="变化问题"></a>变化问题</h2><p>假设存在平行世界，在这个世界中一年的每个月都比我们的世界少一天，除此之外该平行世界的平年闰年、大小月都与我们所处的世界一致。如何计算任意日期是该世界的星期几？</p><p>这个时候蔡勒公式就不太好使了，起码你一时半会儿想不出参数如何变化的。既然时间复杂度和空间复杂度都是O(1)，那我们不妨直接用传统的方法来计算：</p><pre><code class="lang-py">def compute_date_shrink(y, m, d):    isleap = False    if (y % 4 == 0 and y % 100 != 0) or y % 400 == 0:        isleap = True    y = y - 1  # 计算经过了完整的多少年    yd = 353 * y + y // 4 - y // 100 + y // 400    month_arr = [30, 27, 30, 29, 30, 29, 30, 30, 29, 30, 29, 30]    leap_month_arr = [30, 28, 30, 29, 30, 29, 30, 30, 29, 30, 29, 30]    if isleap:        md = sum(leap_month_arr[:m - 1])    else:        md = sum(month_arr[:m - 1])    # print(yd, md, d)    return yd + md + d</code></pre><p>其实我自己也实现了蔡勒公式的变种方法，但是解释起来过于复杂。由于虚拟历法没有现实参照，我也不知道我写的程序对不对，只能把程序放在最后，供大家参考。</p><pre><code class="lang-py">def zellers_shrinked(y, m, d):    if m &lt; 3:        y -= 1        m += 12    return 353 * y + y // 4 - y // 100 + y // 400 + (148 * m - 447) // 5 + d - 295</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知某年月日，如何得到这一天是星期几？&lt;br&gt;已知两日期的年月日，如何得到这两日期之间相差多少天？&lt;br&gt;如此种种问题，均可以利用蔡勒公式解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="algorithm" scheme="https://superlova.github.io/tags/algorithm/"/>
    
      <category term="zeller" scheme="https://superlova.github.io/tags/zeller/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Docker镜像与容器</title>
    <link href="https://superlova.github.io/2021/04/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"/>
    <id>https://superlova.github.io/2021/04/15/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/</id>
    <published>2021-04-15T14:57:55.000Z</published>
    <updated>2021-04-15T17:03:15.200Z</updated>
    
    <content type="html"><![CDATA[<p>Datawhale Docker学习笔记第二篇<br><a id="more"></a></p><h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><ul><li>获取镜像</li></ul><p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p><ul><li>列出镜像</li></ul><p>docker image ls</p><ul><li>删除本地镜像</li></ul><p>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p><ul><li>Dockerfile构建镜像</li></ul><p>如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>在项目的根目录下，新建一个文本文件 Dockerfile</p><p>入下面的内容。</p><p>FROM node:8.4<br>COPY . /app<br>WORKDIR /app<br>RUN npm install —registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>EXPOSE 3000</p><p>上面代码一共五行，含义如下。</p><p>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。<br>COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。<br>WORKDIR /app：指定接下来的工作路径为/app。<br>RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。<br>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</p><p>有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了</p><h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。</p><ul><li>新建并启动容器</li></ul><p>使用 ubuntu 输出一个 “Hello World”，之后终止容器。</p><p>docker run ubuntu:18.04 /bin/echo ‘Hello world’<br>Hello world</p><p>启动一个 bash 终端，允许用户进行交互</p><p>docker run -t -i ubuntu:18.04 /bin/bash<br>root@af8bae53bdd3:/#</p><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><p>检查本地是否存在指定的镜像，不存在就从registry下载<br>利用镜像创建并启动一个容器<br>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层<br>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去<br>从地址池配置一个 ip 地址给容器<br>执行用户指定的应用程序<br>执行完毕后容器被终止</p><ul><li>启动已终止的容器</li></ul><p>可以利用 docker container start 命令，直接将一个已经终止（exited）的容器启动运行。</p><ul><li>停止容器</li></ul><p>docker stop可以停止运行的容器。理解：容器在docker host中实际上是一个进程，docker stop命令本质上是向该进程发送一个SIGTERM信号。如果想要快速停止容器，可使用docker kill命令，其作用是向容器进程发送SIGKILL信号。</p><p>docker ps 列出容器，默认列出只在运行的容器；加-a可以显示所有的容器</p><ul><li>重启容器</li></ul><p>对于已经处于停止状态的容器，可以通过docker start重新启动。docker start会保留容器的第一次启动时的所有参数。docker restart可以重启容器，其作用就是依次执行docker stop和docker start。</p><ul><li>后台运行容器</li></ul><p>添加 -d 参数来实现后台运行容器。在使用 -d 参数时，容器启动后会进入后台，启动完容器之后会停在host端；某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令</p><p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p><p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><p>attach和exec的区别<br>attach和exec的区别： （1）attach直接进入容器启动命令的终端，不会启动新的进程； （2）exec则是在容器中打开新的终端，并且可以启动新的进程； （3）如果想直接在终端中查看命令的输出，用attach，其他情况使用exec；</p><ul><li>删除容器</li></ul><p>可以使用 docker container rm 来删除一个处于终止状态的容器。</p><p>docker container rm trusting_newton<br>trusting_newton</p><p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p><p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><p>docker container prune</p><p>批量删除所有已经退出的容器</p><p>docker rm -v $(docker ps -aq -f status=exited)</p><ul><li>导出容器</li></ul><p>如果要导出本地某个容器，可以使用 docker export 命令。</p><p>这样将导出容器快照到本地文件。</p><ul><li>导入容器</li></ul><p>可以使用 docker import 从容器快照文件中再导入为镜像</p><p>$ cat ubuntu.tar | docker import - test/ubuntu:v1.0<br>$ docker image ls<br>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE<br>test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</p><p>用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datawhale Docker学习笔记第二篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Docker" scheme="https://superlova.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Docker的安装</title>
    <link href="https://superlova.github.io/2021/04/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://superlova.github.io/2021/04/13/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Docker%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2021-04-12T16:34:56.000Z</published>
    <updated>2021-04-12T17:03:11.959Z</updated>
    
    <content type="html"><![CDATA[<p>Datawhale Docker学习笔记第一篇<br><a id="more"></a></p><p>为了今后的方便，我选择将Docker安装在实验室的电脑上，服务器的操作系统为 Ubuntu 18.04 LTS 。整个安装过程参考这篇文章(<a href="https://vuepress.mirror.docker-practice.com/install/ubuntu)。" target="_blank" rel="noopener">https://vuepress.mirror.docker-practice.com/install/ubuntu)。</a></p><p>我曾在一款老旧的笔记本电脑上尝试过安装 Docker ，但是最终失败了，原因是 Docker 不支持 32 位的操作系统。震惊！ Docker竟然不支持 32位操作系统！</p><p>由于我没有安装过老版本，因此不需要执行卸载旧版本的语句。直接执行</p><pre><code class="lang-sh">$ sudo apt-get update$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg \    lsb-release</code></pre><p>这里还出现了一些小插曲，当我执行完上面的 install 语句后，我与服务器建立的 ssh 连接断掉了，之后我试图重新连接居然提示密码错误。最后我重启虚拟机，修改 /etc/ssh/sshd_config 中的 PermitRootLogin 字段为 yes 解决了该问题。</p><p>添加软件源的 GPG 密钥，下载并安装，这一部分不再赘述。</p><pre><code class="lang-sh">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg$ echo \  &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><p>之后启动 Docker 服务：</p><pre><code class="lang-sh">$ sudo systemctl enable docker$ sudo systemctl start docker</code></pre><p>激动人心的时刻到了，测试下 Docker 是否安装成功，执行一个 Hello World 看看：</p><pre><code class="lang-sh">$ sudo docker run --rm hello-world</code></pre><p><img src="/2021/04/13/【学习笔记】Docker的安装/2021-04-13-00-48-07.png" srcset="/img/loading.gif" alt></p><p>大功告成！收工睡觉~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datawhale Docker学习笔记第一篇&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Docker" scheme="https://superlova.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】机器学习——支持向量机SVM</title>
    <link href="https://superlova.github.io/2020/12/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/"/>
    <id>https://superlova.github.io/2020/12/29/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/</id>
    <published>2020-12-29T11:57:32.000Z</published>
    <updated>2021-01-26T07:01:41.538Z</updated>
    
    <content type="html"><![CDATA[<p>什么是SVM？SVM是如何用于分类的？为什么求解对偶问题？核函数的原理是什么？<br><a id="more"></a></p><h1 id="什么是支持向量机（Support-Vector-Machine-SVM）"><a href="#什么是支持向量机（Support-Vector-Machine-SVM）" class="headerlink" title="什么是支持向量机（Support Vector Machine, SVM）"></a>什么是支持向量机（Support Vector Machine, SVM）</h1><p>支持向量机是一种二分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机。通过核技巧，支持向量机可以处理非线性分类问题。</p><p>支持向量机的学习算法是求解凸二次规划的最优化算法。</p><p>由于算法确定超平面时需要使用距离超平面最近的几个训练样本点，这些样本被称为“支持向量”，支持向量机由此得名。</p><p>假设训练样本<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-56-41.png" srcset="/img/loading.gif" alt></p><p>则超平面可以这样表示<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-56-54.png" srcset="/img/loading.gif" alt></p><p>这也就意味着<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-57-06.png" srcset="/img/loading.gif" alt></p><p>选取那些离超平面最近的两个不同类别的数据点，将他们带入超平面方程，发现<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-57-21.png" srcset="/img/loading.gif" alt><br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-57-25.png" srcset="/img/loading.gif" alt></p><p>则两个点到超平面距离之和为<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-57-37.png" srcset="/img/loading.gif" alt></p><p>这是由于点到直线的距离公式为<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-57-49.png" srcset="/img/loading.gif" alt></p><p>这几个令分子为1的数据点，就被称作支持向量。</p><h1 id="支持向量机如何分类"><a href="#支持向量机如何分类" class="headerlink" title="支持向量机如何分类"></a>支持向量机如何分类</h1><p>支持向量机的学习算法的目标是在特征空间中找到一个分离超平面，能将实例分到不同的类。当数据线性可分时，存在无数个分离超平面能将实例正确分开。感知机利用误分类最小的策略，而支持向量机则利用间隔最大化求得最优超平面，这时解是唯一的。</p><p>选取那些支持向量，即距离超平面最近的两个样本点，计算它们到超平面的距离2/||w||<br>通过优化2/||w||使之最大化，便可使得边距扩大。为了寻找超平面 $ F(x)=wx+b $ ，支持向量机试图求解这个优化问题：<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-59-04.png" srcset="/img/loading.gif" alt></p><p>可以转化为<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-54-11.png" srcset="/img/loading.gif" alt></p><p>高等数学告诉我们，求解带有限制条件的优化问题，拉格朗日乘子法是经常用于考虑的方法。<br>问题转化为：<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-20-59-33.png" srcset="/img/loading.gif" alt></p><p>也就是说，将带N个约束条件的二次优化问题，转换为无约束优化问题。<br>这里注意限制条件变成了1-。。。这是因为拉格朗日乘数法要求参数必须大于等于零，限制条件需要相遇等于零。</p><p>由此，问题变成了$\min_{w,b}\max_{\lambda}\mathcal{L}(w,b,\lambda)$<br>先把$\lambda$视作参数，将$w,b$视作常数，求$\mathcal{L}$的最大值。</p><p>$\min_{w,b} \max_{\lambda} \mathcal{L}(w,b,\lambda)$和原问题是等价的。</p><h1 id="为什么求解对偶问题"><a href="#为什么求解对偶问题" class="headerlink" title="为什么求解对偶问题"></a>为什么求解对偶问题</h1><p>由于满足KKT条件，进而将原问题转化为对偶问题，即更换求解max和min 的次序。<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-21-11-01.png" srcset="/img/loading.gif" alt></p><p>可以看到，原问题的限制条件中包含较为复杂的线性不等式，这是阻碍我们进行优化的问题所在；而其对偶问题不但简化了限制条件，而且包含$\sum{\lambda_iy_i}=0$很容易消去，极大降低了求解难度。</p><h1 id="核函数的原理"><a href="#核函数的原理" class="headerlink" title="核函数的原理"></a>核函数的原理</h1><p>计算两个向量在隐式映射过后的空间中的内积的函数叫做核函数（Kernel Function）<br><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-21-16-23.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-21-27-34.png" srcset="/img/loading.gif" alt></p><p><img src="/2020/12/29/【学习笔记】机器学习——支持向量机SVM/2020-12-29-21-27-49.png" srcset="/img/loading.gif" alt></p><p>核函数目的：把原坐标系里线性不可分的数据用Kernel投影到另一个空间，尽量使得数据在新的空间里线性可分。</p><p>核函数的特点：</p><p>1）核函数的引入避免了“维数灾难”，大大减小了计算量。而输入空间的维数n对核函数矩阵无影响，因此，核函数方法可以有效处理高维输入。</p><p>2）无需知道非线性变换函数$\phi$的形式和参数.</p><p>3）核函数的形式和参数的变化会隐式地改变从输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种核函数方法的性能。</p><p>4）核函数方法可以和不同的算法相结合，形成多种不同的基于核函数技术的方法，且这两部分的设计可以单独进行，并可以为不同的应用选择不同的核函数和算法。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《机器学习》周志华</p><p>《统计学习方法》李航</p><p>《机器学习基础》梅尔亚·莫里等</p><p>SVM入门（七）为何需要核函数：<a href="http://www.blogjava.net/zhenandaci/archive/2009/03/06/258288.html" target="_blank" rel="noopener">http://www.blogjava.net/zhenandaci/archive/2009/03/06/258288.html</a></p><p>如何通俗地讲解对偶问题？尤其是拉格朗日对偶lagrangian duality？知乎回答：<a href="https://www.zhihu.com/question/58584814" target="_blank" rel="noopener">https://www.zhihu.com/question/58584814</a></p><p>为什么支持向量机要用拉格朗日对偶算法来解最大化间隔问题？知乎回答：<a href="https://www.zhihu.com/question/36694952" target="_blank" rel="noopener">https://www.zhihu.com/question/36694952</a></p><p>简易解说拉格朗日对偶（Lagrange duality）：<a href="https://www.cnblogs.com/90zeng/p/Lagrange_duality.html" target="_blank" rel="noopener">https://www.cnblogs.com/90zeng/p/Lagrange_duality.html</a></p><p>拉格朗日对偶性：<a href="https://www.cnblogs.com/nxf-rabbit75/p/11453355.html" target="_blank" rel="noopener">https://www.cnblogs.com/nxf-rabbit75/p/11453355.html</a></p><p>机器学习白板推导：<a href="https://www.bilibili.com/video/BV1aE411o7qd" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1aE411o7qd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是SVM？SVM是如何用于分类的？为什么求解对偶问题？核函数的原理是什么？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="machine learning" scheme="https://superlova.github.io/tags/machine-learning/"/>
    
      <category term="SVM" scheme="https://superlova.github.io/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】Ubuntu 18.04 安装Go的踩坑指南</title>
    <link href="https://superlova.github.io/2020/10/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Ubuntu-18-04-%E5%AE%89%E8%A3%85Go%E7%9A%84%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://superlova.github.io/2020/10/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91Ubuntu-18-04-%E5%AE%89%E8%A3%85Go%E7%9A%84%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2020-10-02T03:26:10.000Z</published>
    <updated>2020-10-02T06:56:11.134Z</updated>
    
    <content type="html"><![CDATA[<p>Go安装中遇到的坑<br><a id="more"></a></p><p>gvm是第三方开发的Go多版本管理工具，利用gvm下载和安装go。</p><p>执行以下代码时，你应该确保自己安装有curl</p><pre><code>bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</code></pre><p>在执行上述curl时，我的ubuntu 18.04报错</p><p>curl: (7) Failed to connect to <a href="http://raw.githubusercontent.com/" target="_blank" rel="noopener">raw.githubusercontent.com</a> port 443: Connection refused</p><p>经过<a href="[https://github.com/hawtim/blog/issues/10](https://github.com/hawtim/blog/issues/10">这个</a>)帖子的指引，我在hosts中添加了如下几行：</p><p>199.232.68.133 raw.githubusercontent.com</p><p>199.232.68.133 user-images.githubusercontent.com</p><p>199.232.68.133 avatars2.githubusercontent.com</p><p>199.232.68.133 avatars1.githubusercontent.com</p><p>curl便可以正常下载了。</p><p>安装完成gvm后我们就可以安装go了：</p><pre><code>gvm install go1.15.2gvm use go1.15.2</code></pre><p>这个时候出现错误</p><p>zyt@ubuntu:~$ gvm install go1.15.2<br>Installing go1.15.2…</p><ul><li>Compiling…<br>/home/zyt/.gvm/scripts/install: line 84: go: command not found<br>ERROR: Failed to compile. Check the logs at /home/zyt/.gvm/logs/go-go1.15.2-compile.log<br>ERROR: Failed to use installed version</li></ul><p>经查询，Go版本在1.5以上，需要在指令最后加上-B</p><p><a href="https://github.com/moovweb/gvm#a-note-on-compiling-go-15" target="_blank" rel="noopener">https://github.com/moovweb/gvm#a-note-on-compiling-go-15</a></p><p>zyt@ubuntu:~$ gvm install go1.15.2 -B<br>Installing go1.15.2 from binary source</p><pre><code>gvm use go1.15.2export GOROOT_BOOTSTRAP=$GOROOTgvm install go1.5zyt@ubuntu:~$ gvm listgvm gos (installed)=&gt; go1.15.2zyt@ubuntu:~$ gvm listallgvm gos (available)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Go安装中遇到的坑&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Golang" scheme="https://superlova.github.io/tags/Golang/"/>
    
      <category term="安装" scheme="https://superlova.github.io/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>【竞赛打卡】leetcode打卡：查找算法2</title>
    <link href="https://superlova.github.io/2020/08/27/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91leetcode%E6%89%93%E5%8D%A1%EF%BC%9A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%952/"/>
    <id>https://superlova.github.io/2020/08/27/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91leetcode%E6%89%93%E5%8D%A1%EF%BC%9A%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%952/</id>
    <published>2020-08-27T11:32:22.000Z</published>
    <updated>2020-10-23T05:48:38.865Z</updated>
    
    <content type="html"><![CDATA[<p>见多了优秀的文章，再写博客的时候就会感叹自己的学识浅薄。<br><a id="more"></a></p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h2><pre><code class="lang-cpp">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        if (nums.empty()) return {};        unordered_map&lt;int, int&gt; hash;        vector&lt;int&gt; res;        // construct dict        for (int i = 0; i &lt; nums.size(); ++i) {            hash[nums[i]] = i;        }        for (int i = 0; i &lt; nums.size(); ++i) {            int temp = target - nums[i];            auto iter = hash.find(temp);            if (iter != hash.end() &amp;&amp; iter-&gt;second != i) {                res.push_back(i);                res.push_back(iter-&gt;second);                break;            }        }        return res;    }};</code></pre><p>思想：用hash把待查数组保存起来，这样再次查找的时间就是O(1)了。</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h2><pre><code class="lang-py">class Solution:    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:        res = []        size = len(nums)        if size &lt; 3: return res        nums.sort()        for i in range(size-2):            if i &gt; 0 and nums[i] == nums[i-1]: continue            j = i + 1            k = size - 1            while j &lt; k:                ans = nums[i] + nums[j] + nums[k]                if (ans &gt; 0): k = k - 1                elif (ans &lt; 0): j = j + 1                else:                    res.append([nums[i], nums[j], nums[k]])                    while j &lt; size and nums[j] == nums[j-1]: j += 1                    k -= 1                    while k &gt;= 0 and nums[k] == nums[k+1]: k -= 1        return res</code></pre><p>思想：用三个下标<code>i,j,k</code>遍历所有可能。首先排序，然后不断缩小i、j和k的区间。</p><h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16 最接近的三数之和"></a>16 最接近的三数之和</h2><pre><code class="lang-cpp">class Solution {public:    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {        const int size = nums.size();        if (size &lt;= 3) return std::accumulate(nums.begin(), nums.end(), 0); // 0是累加的初值        std::sort(nums.begin(), nums.end());        int result = nums[0] + nums[1] + nums[2]; // 初值        for (int i = 0; i &lt; size - 2; ++i) {            int j = i + 1;            int k = size - 1;            while (j &lt; k) {                int temp = nums[i] + nums[j] + nums[k];                if (std::abs(target - temp) &lt; std::abs(target - result)) {                    result = temp;                }                if (result == target) { // 直接找到了                    return result;                }                if (temp &gt; target) {                    --k; // temp太大，需要缩小右边界                } else {                    ++j; // temp太小，需要缩小左边界                }            }        }        return result;    }};</code></pre><p>思路：还是利用三个下标<code>i,j,k</code>遍历全部数组。中途不断保存和target最近的temp值。</p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18 四数之和"></a>18 四数之和</h2><pre><code class="lang-cpp">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {        sort(nums.begin(),nums.end());        vector&lt;vector&lt;int&gt; &gt; res;        if(nums.size()&lt;4) return res;        int a,b,c,d,_size=nums.size();        for(a=0;a&lt;_size-3;a++){            if(a&gt;0&amp;&amp;nums[a]==nums[a-1]) continue;      //确保nums[a] 改变了            for(b=a+1;b&lt;_size-2;b++){                if(b&gt;a+1&amp;&amp;nums[b]==nums[b-1])continue;   //确保nums[b] 改变了                c=b+1,d=_size-1;                while(c&lt;d){                    if(nums[a]+nums[b]+nums[c]+nums[d]&lt;target)                        c++;                    else if(nums[a]+nums[b]+nums[c]+nums[d]&gt;target)                        d--;                    else{                        res.push_back({nums[a],nums[b],nums[c],nums[d]});                        while(c&lt;d&amp;&amp;nums[c+1]==nums[c])      //确保nums[c] 改变了                            c++;                        while(c&lt;d&amp;&amp;nums[d-1]==nums[d])      //确保nums[d] 改变了                            d--;                        c++;                        d--;                    }                }            }        }        return res;    }};</code></pre><p>思路：四指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;见多了优秀的文章，再写博客的时候就会感叹自己的学识浅薄。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="algorithm" scheme="https://superlova.github.io/tags/algorithm/"/>
    
      <category term="leetcode" scheme="https://superlova.github.io/tags/leetcode/"/>
    
      <category term="Datawhale" scheme="https://superlova.github.io/tags/Datawhale/"/>
    
      <category term="search" scheme="https://superlova.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>【竞赛打卡】数据挖掘实践——总结与反思</title>
    <link href="https://superlova.github.io/2020/08/25/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D/"/>
    <id>https://superlova.github.io/2020/08/25/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93%E4%B8%8E%E5%8F%8D%E6%80%9D/</id>
    <published>2020-08-25T15:28:03.000Z</published>
    <updated>2020-08-25T15:33:14.930Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>这次组队学习确实是自己不太擅长的领域。借着上次NLP组队学习的冲劲，本以为想在不熟悉的领域也能至少学点东西，但确实是小看了这次学习的难度。</p><p>回头来看，组队学习进入到特征工程的时候，我已经完全一脸懵逼了。我很想跟上大家的节奏，但是确实一个是没有时间，另一个是差太多了，已经进入了恐慌区，脑海里也是拒绝的心态。我知道这次组队学习已经彻底失败了。</p><p>唉！内心充满了挫败感。这次组队学习唯一的收获就是，获得了这次比赛的Baseline。自此之后我就要投入到秋招了，我曾参加过CV赛事、NLP赛事，再加上这个结构化赛事，我的比赛经历算是圆满了，接下来的日子就是研究Baseline、好好准备简历了，也该收收心了。</p><p>祝自己好运。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这次组队学习确实是自己不太擅长的领域。借着上次NLP组队学习的冲劲，本以为想在不熟悉的领域也能至少学点东西，但确实是小看了这次学习的难度。&lt;/p&gt;
&lt;p&gt;回头来看，组队学习进入到特征工程的时候，我已经完全一脸懵逼了。我很想跟上大家的节奏，
      
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Datawhale" scheme="https://superlova.github.io/tags/Datawhale/"/>
    
      <category term="Data Mining" scheme="https://superlova.github.io/tags/Data-Mining/"/>
    
      <category term="Time Series Analysis" scheme="https://superlova.github.io/tags/Time-Series-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>【竞赛打卡】数据挖掘实践——建模预测</title>
    <link href="https://superlova.github.io/2020/08/24/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%BB%BA%E6%A8%A1%E9%A2%84%E6%B5%8B/"/>
    <id>https://superlova.github.io/2020/08/24/%E3%80%90%E7%AB%9E%E8%B5%9B%E6%89%93%E5%8D%A1%E3%80%91%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E5%BB%BA%E6%A8%A1%E9%A2%84%E6%B5%8B/</id>
    <published>2020-08-24T15:05:13.000Z</published>
    <updated>2020-08-24T15:41:46.921Z</updated>
    
    <content type="html"><![CDATA[<p>我也是加把劲骑士！<br><a id="more"></a></p><pre><code class="lang-py">import matplotlib.pyplot as pltimport pandas as pdimport numpy as npfrom tensorflow.keras.layers import Input, Conv1D, MaxPooling1D, Dense, Add, Dropout, Flatten, TimeDistributedfrom tensorflow.keras.models import Model, Sequentialfrom tensorflow.keras import activations, optimizers, regularizersfrom tensorflow.keras.callbacks import EarlyStoppingimport tensorflow.keras.backend as kbfrom tensorflow import kerasfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.metrics import mean_squared_error, mean_absolute_errorfrom time import *user_balance = pd.read_csv(&#39;Purchase Redemption Data/user_balance_table.csv&#39;)df_tmp = user_balance.groupby([&#39;report_date&#39;])[&#39;total_purchase_amt&#39;, &#39;total_redeem_amt&#39;].sum()df_tmp.index = pd.to_datetime(df_tmp.index, format=&#39;%Y%m%d&#39;)holidays = (&#39;20130813&#39;, &#39;20130902&#39;, &#39;20131001&#39;, &#39;20131111&#39;, &#39;20130919&#39;, &#39;20131225&#39;, &#39;20140101&#39;, &#39;20140130&#39;, &#39;20140131&#39;,           &#39;20140214&#39;, &#39;20140405&#39;, &#39;20140501&#39;, &#39;20140602&#39;, &#39;20140802&#39;, &#39;20140901&#39;, &#39;20140908&#39;)def create_features(timeindex):    n = len(timeindex)    features = np.zeros((n, 4))    features[:, 0] = timeindex.day.values/31    features[:, 1] = timeindex.month.values/12    features[:, 2] = timeindex.weekday.values/6    for i in range(n):        if timeindex[i].strftime(&#39;%Y%m%d&#39;) in holidays:            features[i, 3] = 1    return featuresfeatures = create_features(df_tmp.index)september = pd.to_datetime([&#39;201409%02d&#39; % i for i in range(1, 31)])features_sep = create_features(september)scaler_pur = MinMaxScaler()scaler_red = MinMaxScaler()data_pur = scaler_pur.fit_transform(df_tmp.values[:, 0:1])data_red = scaler_red.fit_transform(df_tmp.values[:, 1:2])def create_dataset(data, back, forward=30):    n_samples = len(data) - back - forward + 1    X, Y = np.zeros((n_samples, back, data.shape[-1])), np.zeros((n_samples, forward, data.shape[-1]))    for i in range(n_samples):        X[i, ...] = data[i:i+back, :]        Y[i, ...] = data[i+back:i+back+forward, :]    return X, Ydef build_cnn(X_trn, lr, n_outputs, dropout_rate):    inputs = Input(X_trn.shape[1:])    z = Conv1D(64, 14, padding=&#39;valid&#39;, activation=&#39;relu&#39;, kernel_initializer=&#39;he_uniform&#39;)(inputs)#     z = MaxPooling1D(2)(z)    z = Conv1D(128, 7, padding=&#39;valid&#39;, activation=&#39;relu&#39;, kernel_initializer=&#39;he_uniform&#39;)(z)    z = MaxPooling1D(2)(z)    z = Conv1D(256, 3, padding=&#39;valid&#39;, activation=&#39;relu&#39;, kernel_initializer=&#39;he_uniform&#39;)(z)    z = Conv1D(256, 3, padding=&#39;valid&#39;, activation=&#39;relu&#39;, kernel_initializer=&#39;he_uniform&#39;)(z)    z = MaxPooling1D(2)(z)    z = Flatten()(z)    z = Dropout(dropout_rate)(z)    z = Dense(128, activation=&#39;relu&#39;, kernel_initializer=&#39;he_uniform&#39;)(z)    z = Dropout(dropout_rate)(z)    z = Dense(84, activation=&#39;relu&#39;, kernel_initializer=&#39;he_uniform&#39;)(z)    outputs = Dense(n_outputs)(z)    model = Model(inputs=inputs, outputs=outputs)    adam = optimizers.Adam(lr=lr)    model.compile(loss=&#39;mse&#39;, optimizer=adam, metrics=[&#39;mae&#39;])    model.summary()    return modelback = 60forward = 30X_pur_data, Y_pur_data = create_dataset(data_pur, back, forward)X_red_data, Y_red_data = create_dataset(data_red, back, forward)X_features, Y_features = create_dataset(features, back, forward)Y_features = np.concatenate((Y_features, np.zeros((Y_features.shape[0], back-forward, Y_features.shape[-1]))), axis=1)# X_pur, X_red = np.concatenate((X_pur_data, X_features, Y_features), axis=-1), np.concatenate((X_red_data, X_features, Y_features), axis=-1)# X_pur_trn, X_pur_val, X_red_trn, X_red_val = X_pur[:-forward, ...], X_pur[-1:, ...], X_red[:-forward, ...], X_red[-1:, ...]# Y_pur_trn, Y_pur_val, Y_red_trn, Y_red_val = Y_pur_data[:-forward, ...], Y_pur_data[-1:, ...], Y_red_data[:-forward, ...], Y_red_data[-1:, ...]Y_fea_sep = np.concatenate((features_sep, np.zeros((back-forward, features_sep.shape[-1]))), axis=0)# X_pur_tst = np.concatenate((data_pur[-back:, :], features[-back:, :], Y_fea_sep), axis=-1)[None, ...]# X_red_tst = np.concatenate((data_red[-back:, :], features[-back:, :], Y_fea_sep), axis=-1)[None, ...]X = np.concatenate((X_pur_data, X_red_data, X_features, Y_features), axis=-1)Y = np.concatenate((Y_pur_data, Y_red_data), axis=1)X_trn, X_val, Y_trn, Y_val = X[:-forward, ...], X[-1:, ...], Y[:-forward, ...], Y[-1:, ...]X_tst = np.concatenate((data_pur[-back:, :], data_red[-back:, :], features[-back:, :], Y_fea_sep), axis=-1)[None, ...]cnn_pur = build_cnn(X_trn, lr=0.0008, n_outputs=2*forward, dropout_rate=0.5)history = cnn_pur.fit(X_trn, Y_trn, batch_size=32, epochs=1000, verbose=2,                       validation_data=(X_val, Y_val),                     callbacks=[EarlyStopping(monitor=&#39;val_mae&#39;, patience=200, restore_best_weights=True)])plt.figure(figsize=(8, 5))plt.plot(history.history[&#39;mae&#39;], label=&#39;train mae&#39;)plt.plot(history.history[&#39;val_mae&#39;], label=&#39;validation mae&#39;)plt.ylim([0, 0.2])plt.legend()plt.show()def plot_prediction(y_pred, y_true):    plt.figure(figsize=(16,4))    plt.plot(np.squeeze(y_pred), label=&#39;prediction&#39;)    plt.plot(np.squeeze(y_true), label=&#39;true&#39;)    plt.legend()    plt.show()    print(&#39;MAE: %.3f&#39; % mean_absolute_error(np.squeeze(y_pred), np.squeeze(y_true)))pred = cnn.predict(X_val)plot_prediction(pred, Y_val)history = cnn.fit(X, Y, batch_size=32, epochs=500, verbose=2,                     callbacks=[EarlyStopping(monitor=&#39;mae&#39;, patience=30, restore_best_weights=True)])plt.figure(figsize=(8, 5))plt.plot(history.history[&#39;mae&#39;], label=&#39;train mae&#39;)plt.legend()plt.show()print(cnn.evaluate(X, Y, verbose=2))pred_tst = cnn.predict(X_tst)pur_sep = scaler_pur.inverse_transform(pred_tst[:, :forward].transpose())red_sep = scaler_red.inverse_transform(pred_tst[:, forward:].transpose())test_user = pd.DataFrame({&#39;report_date&#39;: [20140900 + i for i in range(1, 31)]})test_user[&#39;pur&#39;] = pur_sep.astype(&#39;int&#39;)test_user[&#39;red&#39;] = red_sep.astype(&#39;int&#39;)test_user.to_csv(&#39;submission.csv&#39;, encoding=&#39;utf-8&#39;, index=None, header=None)from google.colab import filesfiles.download(&quot;submission.csv&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我也是加把劲骑士！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="https://superlova.github.io/categories/notes/"/>
    
    
      <category term="Datawhale" scheme="https://superlova.github.io/tags/Datawhale/"/>
    
      <category term="Data Mining" scheme="https://superlova.github.io/tags/Data-Mining/"/>
    
      <category term="Time Series Analysis" scheme="https://superlova.github.io/tags/Time-Series-Analysis/"/>
    
  </entry>
  
</feed>
